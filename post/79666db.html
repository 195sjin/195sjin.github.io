<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>数据结构 | 衿</title><meta name="author" content="衿"><meta name="copyright" content="衿"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、线性表线性表的类型定义​       线性表是一个相当灵活的数据结构，其长度可根据需要增长或缩短，即对线性表的数据元素 不仅可以进行访问，而且可以进行插入和删除等操作。 逻辑特征： 在非空的线性表，有且仅有一个开始结点，有且仅有一个终端结点， 其余的内部节点都有且仅有一个直接前驱和一个直接后继 c里面释放空间：free( p ) ​		 p是一个指针类型的变量 c++里面释放空间：delete">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构">
<meta property="og:url" content="http://example.com/post/79666db.html">
<meta property="og:site_name" content="衿">
<meta property="og:description" content="一、线性表线性表的类型定义​       线性表是一个相当灵活的数据结构，其长度可根据需要增长或缩短，即对线性表的数据元素 不仅可以进行访问，而且可以进行插入和删除等操作。 逻辑特征： 在非空的线性表，有且仅有一个开始结点，有且仅有一个终端结点， 其余的内部节点都有且仅有一个直接前驱和一个直接后继 c里面释放空间：free( p ) ​		 p是一个指针类型的变量 c++里面释放空间：delete">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hakaimg.com/i/2022/10/05/nwneti.png">
<meta property="article:published_time" content="2022-10-22T10:58:43.000Z">
<meta property="article:modified_time" content="2022-12-01T12:05:42.596Z">
<meta property="article:author" content="衿">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hakaimg.com/i/2022/10/05/nwneti.png"><link rel="shortcut icon" href="/img/wztb.png"><link rel="canonical" href="http://example.com/post/79666db"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#002FA7","bgDark":"#003153","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-01 20:05:42'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mycss.css"><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-clock/lib/clock.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/tx.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://hakaimg.com/i/2022/10/05/nwneti.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">衿</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-22T10:58:43.000Z" title="发表于 2022-10-22 18:58:43">2022-10-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-01T12:05:42.596Z" title="更新于 2022-12-01 20:05:42">2022-12-01</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、线性表"><a href="#一、线性表" class="headerlink" title="一、线性表"></a>一、线性表</h1><h2 id="线性表的类型定义"><a href="#线性表的类型定义" class="headerlink" title="线性表的类型定义"></a>线性表的类型定义</h2><p>​       线性表是一个相当灵活的数据结构，其长度可根据需要增长或缩短，即对线性表的数据元素 不仅可以进行访问，而且可以进行插入和删除等操作。</p>
<p>逻辑特征：</p>
<p>在非空的线性表，有且仅有一个开始结点，有且仅有一个终端结点，</p>
<p>其余的内部节点都有且仅有一个直接前驱和一个直接后继</p>
<p>c里面释放空间：free( p )</p>
<p>​		 p是一个指针类型的变量</p>
<p>c++里面释放空间：delete( p )</p>
<p>​		p是一个指针类型的变量</p>
<h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p>​		用一组<strong>地址连续</strong>的存储单元依次存储线性表的数据元素， 这种表示 也称作线性表的顺序存储结构或顺序映像。</p>
<p>其特点是，<strong>逻辑上相邻的数据元素， 其物理次序也是相邻的。</strong></p>
<p>​		只要确定了存储线性表的起始位置， 线性表中任一数据元素都可随 机存取， 所以线性表的顺序存储结构是一种<strong>随机存取</strong>的存储结构。</p>
<p>计算顺序表中元素存储位置	LOC(ai)&#x3D;LOC(a1)+(i-1)*L  ——-&gt;L表示每个元素需要占据L个存储单元</p>
<p>通常都用数组来描述数据结构中的顺序 存储结构。但是顺序表的长度可以变，而数组的长度不可以变，因此C语言中可用动态分配的一维数组表示线性表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//顺序表的存储结构</span><br><span class="line">#define MAXSIZE 100</span><br><span class="line">typedef struct&#123;</span><br><span class="line">ElemType *elem; ／／是一个动态分配数组，存储空间的基地址</span><br><span class="line">int length; ／／当前长度</span><br><span class="line">&#125;SqList; ／/顺序表的结构类型为SqList</span><br><span class="line">动态分配数组的内存</span><br><span class="line">L.elem=(ElemType*)malloc(sizeof(ElemType)*MAXSIZE);</span><br></pre></td></tr></table></figure>

<h3 id="顺序表的基本操作"><a href="#顺序表的基本操作" class="headerlink" title="顺序表的基本操作"></a>顺序表的基本操作</h3><p><strong>顺序表的初始化</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Status InitList(SqList &amp;L) </span><br><span class="line">｛／／构造一个空的顺序表 L</span><br><span class="line">L.elem= new ElemType[MAXSIZE]; //为顺序表分配一个大小为MAXSIZE的数组空间</span><br><span class="line">if (! L. elem) exit (OVERFLOW); /／存储分配失败退出</span><br><span class="line">L.length=O; ／／空表长度为0</span><br><span class="line">return OK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>判断线性表是否为空</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int isEnpty(SqList L)&#123;</span><br><span class="line">if(l/length==0)return 1;</span><br><span class="line">else return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>取值</strong></p>
<p>根据指定的位置序号i, 获取顺序表中第i个数据元素的值。</p>
<p>算法的时间复杂度为0(1)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status GetElem(SqList L,int i,ElemType &amp;e) </span><br><span class="line">if &#123;i&lt;1||i&gt;L.length) return ERROR; //判断i值是否合理，若不合理,返回 ERROR</span><br><span class="line">e=L.elem[i-1];            //elem[i-1] 单元存储第 i 个数据元素</span><br><span class="line">return OK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>查找</strong></p>
<p>查找操作是根据指定的元素值e, 查找顺序表中第1个与e相等的元素。</p>
<p>算法的平均时间复杂度为 O(n)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int LocateELem(SqList L,ElemType e) </span><br><span class="line">｛／／在顺序表1中查找值为e的数据元素， 返回其序号</span><br><span class="line">for(i=O;i&lt; L.length;i++) </span><br><span class="line">if(L.elem[i)==e) return i+l; ／／查找成功， 返回序号 i+l</span><br><span class="line">return O; ／／查找失败， 返回 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>顺序表的插入</strong></p>
<p>1判断插入位置是否合法、2判断存储空间是否已满、3将后面的元素依次后移、4插入、5表长加1</p>
<p>算法的平均时间复杂度为 O(n)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Status ListInsert(SqList &amp;L,int i ,ElemType e) </span><br><span class="line">&#123;//在顺序表L中第i个位置之前插入新的元素 e, i值的合法范围是 1&lt;=i&lt;=L.length+1 </span><br><span class="line">if((i&lt;1) || (i&gt;L.length+1)) return ERROR; //i值不合法</span><br><span class="line">if(L.length==MAXSIZE) return ERROR; ／／当前存储空间已满</span><br><span class="line">for (j=L.length-1; j&gt;=i-1; j--) </span><br><span class="line">L.elem[j+1]=L.elem[j]; ／／插入位置及之后的元素后移</span><br><span class="line">L.elem[i-1)=e;／／将新元素e放入第i个位置</span><br><span class="line">++L.length; ／／表长加1</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>删除</strong></p>
<p>的平均时间复杂度为O(n)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status ListDelete(SqList &amp;L,int i) </span><br><span class="line">&#123;//在顺序表L中删除第i个元素，i值的合法范围是 1&lt;=i&lt;=L.length </span><br><span class="line">if((i&lt;1) || (i&gt;L.length)) return ERROR; ／i值不合法</span><br><span class="line">for (j=i; j &lt;=L. length-1; j ++) </span><br><span class="line">L.elem[j-1)=1.elem[j]; ／／被删除元素之后的元素前移</span><br><span class="line">--L.length; ／／表长减1</span><br><span class="line">return OK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链式表"><a href="#链式表" class="headerlink" title="链式表"></a>链式表</h2><p>特点是：用一组<strong>任意的存储单元</strong>存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）。</p>
<p>结点包括两个域：其中存储数据元素信息的域称为数据域；存储直接后继存储位置的域称为指针域。</p>
<p>整个链表的存取必须从头指针开始进行，头指针指示链表中第一个结点（即第一个数据元素的存储映像，也称首元结点） 的存储位置。</p>
<p>单链表是非随机存取的存储结构,也称为<strong>顺序存取</strong>的存取结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">／／－－－－－ 单链表的存储结构－－－－－</span><br><span class="line">typedef struct LNode </span><br><span class="line">ElemType data; ／／结点的数据域</span><br><span class="line">struct LNode *next; ／/结点的指针域</span><br><span class="line">&#125;LNode,*LinkList; //LinkList 为指向结构体 LNode 的指针类型</span><br></pre></td></tr></table></figure>

<blockquote>
<p>LinkList 与 LNode* , 两者本质上是等价的。通常习惯上用 LinkList 定义单链表，强调定义的是某个单链表的头指针；用 LNode *定义指向单链表中任意结点的指针变量。</p>
<p>例如，若定义 LinkList L,  则L为单链表的头指针，若定义 LNode<em>p, 则p为指向单链表中某个结点的指针，用</em>p 代表 该结点。</p>
<p>注意区分指针变量和结点变量两个不同的概念</p>
<p>若定义 LinkListp 或 LNode<em>p, 则p 为指向某结点的指针变量，表示该结点的地址；而</em>p 为对应的结点变量，表示该结 点的名称。</p>
</blockquote>
<p>一般情况下，为了处理方便，在单链表的第一个结点之前附设一个结点，称之为头结点。</p>
<p>头结点的作用:</p>
<p>(1)便于首元结点的处理</p>
<p>(2)便于空表和非空表的统一处理</p>
<p>当链表不设头结点时，假设 L 为单链表的头指针，它应该指向首元结点，则当单链表为长度 n 为 0 的空表时， L 指针为空（判定空表的条件可记为：L&#x3D;&#x3D; NULL)。</p>
<p>增加头结点后，无论链表是否为空，头指针都是指向头结点的非空指针。若为空表，则头结点的指针域为空（判定空表的条件可记为： L -&gt;next&#x3D;&#x3D; NULL)</p>
<h3 id="单链表的基本操作"><a href="#单链表的基本操作" class="headerlink" title="单链表的基本操作"></a>单链表的基本操作</h3><p><strong>初始化</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tatus InitList(LinkList &amp;L) </span><br><span class="line">｛／／构造一个空的单链表L</span><br><span class="line">L=new LNode; ／／生成新结点作为头结点， 用头指针L指向头结点</span><br><span class="line">//或者 L=(LinkList)malloc(sizeof(LNode));</span><br><span class="line">L-&gt;next=NULL; ／／头结点的指针域置空</span><br><span class="line">return OK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>判断链表是否为空</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int ListEmpty(LinkList L)&#123;</span><br><span class="line">if(L-&gt;next)//非空</span><br><span class="line">return 0;</span><br><span class="line">else</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>求单链表的表长</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int ListLength(LinkList)&#123;//返回L中数据元素个数</span><br><span class="line">LinkList p;</span><br><span class="line">p-&gt;next;//p指向第一个结点</span><br><span class="line">i=0;</span><br><span class="line">while(p)&#123;//遍历单链表，统计结点数</span><br><span class="line">i++;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>取值</strong></p>
<p>算法的平均时间复杂度为O(n)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Status GetElem(LinkList L,int i,ElemType &amp;e)&#123;</span><br><span class="line">//获取线性表L中某个数据元素的内容，通过变量e返回</span><br><span class="line">p=L-&gt;next;j=1;//初始化p指向首元结点，计数器j初值赋为1</span><br><span class="line">while(p&amp;&amp;j&lt;i)&#123;//向后扫描，直到p指向第i个元素或p为空</span><br><span class="line">p=p-&gt;next;++j;</span><br><span class="line">&#125;</span><br><span class="line">if(!p||j&gt;i)return ERROR;//i值不合法 i&gt;n或i&lt;=0</span><br><span class="line">e=p-&gt;data;//取第i个元素</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>按值查找</strong></p>
<p>平均时间复杂度为 O(n)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LNode *LocateELem(LinkList L, Elemtype e) </span><br><span class="line">｛／／在带头结点的单链表L中查找值为e的元素</span><br><span class="line">p=L-&gt;next; ／／初始化，p指向首元结点</span><br><span class="line">while(p &amp;&amp; p-&gt;data!=e) ／／顺链域向后扫描，直到p为空或p所指结点的数据域等于e</span><br><span class="line">p=p-&gt;next; //p指向下一个结点</span><br><span class="line">return p; ／／查找成功返回值为e的结点地址p, 查找失败p为NULL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>单链表的插入</strong></p>
<p>算法的时间复杂度为0(n)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Status Listinsert(LinkList &amp;L,int i,ElemType e) </span><br><span class="line">｛／／在带头结点的单链表L中第i个位置插入值为e的新结点</span><br><span class="line">p=L;j=O; </span><br><span class="line">while (p &amp;&amp; (j&lt;i-1)) </span><br><span class="line">&#123;p=p-&gt;next;++j;&#125; ／／查找第i-1个结点，p指向该结点</span><br><span class="line">if (!p || j&gt;i-1) return ERROR; //i&gt;n+l或者i&lt;1</span><br><span class="line">s=new LNode; </span><br><span class="line">s-&gt;data= e; </span><br><span class="line">s-&gt;next=p-&gt;next;／／将结点 *s的指针域指向结点 a,</span><br><span class="line">p-&gt;next=s; ／／将结点*p的指针域指向结点*s</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>和顺序表一样，如果表中有 n 个结点 ，则插入操作中合法的插入位置有 n+l 个，即 1&lt;&#x3D;i&lt;&#x3D;n+l 。当 i &#x3D;n+l 时，新结点则插在链表尾部。</p>
</blockquote>
<p><strong>单链表的删除</strong></p>
<p>算法的时间复杂度为0(n)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Status ListDelete(LinkList &amp;L,int i) </span><br><span class="line">｛／／在带头结点的单链表L中，删除第i个元素</span><br><span class="line">p=L;j=O; </span><br><span class="line">while ((p-&gt;next) &amp;&amp; (j&lt;i-1)) ／／查找第i-1个结点，p指向该结点</span><br><span class="line">&#123;p=p-&gt;next; ++j;&#125; </span><br><span class="line">if (! (p-&gt;next) || (j&gt;i-1)) return ERROR;//当i&gt;n或i&lt;1时，删除位置不合理</span><br><span class="line">q=p-&gt;next;//临时保存被删结点的地址以备释放</span><br><span class="line">p-&gt;next=q-&gt;next;//改变删除结点前驱结点的指针域</span><br><span class="line">delete q;  //释放删除结点的空间</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除算法中的循环条件(p-&gt;next&amp;&amp;j&lt;i-1)和插入算法中的循环条件(p&amp;&amp;(j&lt;i—1))是有所<br>区别的。</p>
<p>因为插入操作中合法的插入位置有n+l个，而删除操作中合法的删除位置只有n<br>个，如果使用与插入操作相同的循环条件，则会出现引用空指针的情况，使删除操作失败。</p>
</blockquote>
<p><strong>创建单链表</strong></p>
<p><strong>（1）前插法创建</strong></p>
<p>算法的时间复杂度为0(n)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void CreateList_H(LinkList &amp;L,int n) </span><br><span class="line">&#123;//逆位序输入n个元素的值，建立带表头结点的单链表L</span><br><span class="line">L=new LNode;</span><br><span class="line">L-&gt;next=NULL; ／／先建立一个带头结点的空链表</span><br><span class="line">for(i=O;i&lt;n;++i) &#123;</span><br><span class="line">p=new LNode; ／／生成新结点*p</span><br><span class="line">cin&gt;&gt;p-&gt;data; ／／输入元素值赋给新结点*p的数据域</span><br><span class="line">p-&gt;next=L-&gt;next;</span><br><span class="line">L-&gt;next=p; ／／将新结点*p插人到头结点之后</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(2)后插法创建</strong></p>
<p>算法的时间复杂度为0(n)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void CreateList_R(LinkList &amp;L,int n) </span><br><span class="line">｛／／正位序输人n个元素的值， 建立带表头结点的单链表L</span><br><span class="line">L=new LNode; </span><br><span class="line">L-&gt;next=NULL; ／／先建立一个带头结点的空链表</span><br><span class="line">r=L; ／／尾指针r指向头结点</span><br><span class="line">for(i=O;i&lt;n;++i) </span><br><span class="line">p=new LNode; ／／生成新结点</span><br><span class="line">cin&gt;&gt;p-&gt;data; ／／输人元素值赋给新结点*p的数据域</span><br><span class="line">p-&gt;next=NULL;</span><br><span class="line">r-&gt;next=p; ／／将新结点*p插人尾结点*r之后</span><br><span class="line">r=p; //r指向新的尾结点*p</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>其特点是表中最后一个结点 的指针域指向头结点，整个链表形成一个环，即头尾相连，形成一个环。从表中任何一个结点出发均可找到表中其他结点。</p>
<p>判别当前指针p是否 指向表尾结点的终止条件不同。</p>
<p>在单链表中，判别条件为p!&#x3D;NULL或p-&gt;next!&#x3D;NULL, 而循环 单链表的判别条件为p!&#x3D;L或p-&gt;next!&#x3D;L</p>
<p><strong>带尾指针的循环链表的合并</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LinkList Connect(LinkList Ta,LinkList Tb)&#123;</span><br><span class="line">p-&gt;Ta-&gt;next;//p存Ta表头结点</span><br><span class="line">Ta-&gt;next=Tb-&gt;next-&gt;next;//Tb表头结点连接Ta表尾</span><br><span class="line">delete Tb-&gt;next;//释放表头结点</span><br><span class="line">Tb-&gt;next=p;//修改指针</span><br><span class="line">return Tb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>双向链表的结点中有两个指针域，一个指向直接后继， 另一个指向直接前驱。</p>
<p>在双向链表中， 若 d为指向表中某一结点的指针，则d-&gt;next-&gt;prior &#x3D; d-&gt;prior-&gt;next &#x3D; d </p>
<p><strong>双向链表的插入</strong></p>
<p><img src="https://hakaimg.com/i/2022/11/27/ezksjm.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Status Listinsert_DuL(DuLinkList &amp;L,int i,ElemType e) </span><br><span class="line">&#123;//在带头结点的双向链表L中第i个位置之前插入元素e</span><br><span class="line">if (!(p=GetElem_DuL (L, i))) ／／在L中确定第i个元素的位置指针p</span><br><span class="line">return ERROR; //p为 NULL 时，第i个元素不存在</span><br><span class="line">s=new DuLNode; ／／生成新结点*s</span><br><span class="line">s-&gt;data=e; ／／将结点*s数据域置为e</span><br><span class="line">s-&gt;prior=p-&gt;prior; ／／将结点*s插入L,如①</span><br><span class="line">p-&gt;prior-&gt;next=s; //对应②</span><br><span class="line">s-&gt;next=p; //对应③</span><br><span class="line">p-&gt;prior=s; //对应④</span><br><span class="line">return OK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>双链表的删除</strong></p>
<p><img src="https://hakaimg.com/i/2022/11/27/ezna2i.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Status ListDelete_DuL(DuLinkList &amp;L,int i) </span><br><span class="line">&#123;//删除带头结点的双向链表L中的第i个元素</span><br><span class="line">if (! (p=GetElem_DuL (L, i))) ／／在L 中确定第 i个元素的位置指针p</span><br><span class="line">return ERROR; //p为 NULL 时，第i个元素不存在</span><br><span class="line">p-&gt;prior-&gt;next=p-&gt;next; ／／修改被删结点的前驱结点的后继指针，对应①</span><br><span class="line">p-&gt;next-&gt;prior=p-&gt;prior; ／／修改被删结点的后继结点的前驱指针，对应图②</span><br><span class="line">delete p; ／／释放被删结点的空间</span><br><span class="line">return OK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>单链表、循环链表和双向链表的时间效率比较</strong></p>
<p><img src="https://hakaimg.com/i/2022/11/27/f5j8nv.png"></p>
<h2 id="顺序表与链表的比较"><a href="#顺序表与链表的比较" class="headerlink" title="顺序表与链表的比较"></a>顺序表与链表的比较</h2><p><img src="https://hakaimg.com/i/2022/11/27/faekeb.png"></p>
<h2 id="线性表的合并"><a href="#线性表的合并" class="headerlink" title="线性表的合并"></a>线性表的合并</h2><p> LocateElem 的执行时间和表长 m 成正比,时间复杂度为 O(m x n)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void MergeList(List &amp;LA,List LB) </span><br><span class="line">&#123;/ /将所有在线性表 LB中但不在LA中的数据元素插入到LA中</span><br><span class="line">m=ListLength(LA); n=ListLength(LB); //求线性表的长度</span><br><span class="line">for(i=l;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">GetElem(LB,i,e); ／／取 LB中第i个数据元素赋给 e</span><br><span class="line">if (! LocateElem (LA, e)) //LA中不存在和 e 相同的数据元素</span><br><span class="line">Listinsert(LA,++m,e); ／／将 e 插在LA的最后</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="有序表的合并"><a href="#有序表的合并" class="headerlink" title="有序表的合并"></a>有序表的合并</h2><p>若线性表中的数据元素相互之 间可以比较， 并且数据元素在线性表中依值非递减或非递增有 序排列， 则称该线性表为有序表</p>
<p><strong>用顺序表实现</strong></p>
<p>如果两个表长分别记为m和n，算法的时间复杂度为O(m+ n)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void MergeList_Sq(SqList LA,SqList LB,SqList &amp;LC) </span><br><span class="line">&#123;// 已知顺序有序表LA和LB的元素按值非递减排列</span><br><span class="line">／／归并LA和LB得到新的顺序有序表LC, LC的元素也按值非递减排列</span><br><span class="line">LC.length=LA.length+LB.length; //新表长度为待合并两表的长度之和</span><br><span class="line">LC.elern=new ElemType[LC.length]; //为合并后的新表分配一个数组空间</span><br><span class="line">pc=LC.elem; ／／指针pc 指向新表的第一个元素</span><br><span class="line">pa=LA.elem; pb=LB.elem; ／／指针pa 和pb 的初值分别指向两个表的第一个元素</span><br><span class="line">pa_last=LA.elem+LA.length-1; ／／指针pa_last指向LA的最后一个元素</span><br><span class="line">pb_last=LB.elem+LB.length-1;  //指针pb_last指向LB的最后一个元素</span><br><span class="line">while ((pa&lt;=pa_last) &amp;&amp; (pb&lt;=pb_last)) / /LA和LB均未到达表尾</span><br><span class="line">&#123;</span><br><span class="line">if(*pa&lt; =*pb ) *pc++=*pa++; ／／依次 ＂摘取“ 两表中值较小的结点插人到LC的最后</span><br><span class="line">else *pc++=*pb++; </span><br><span class="line">&#125;</span><br><span class="line">while (pa&lt;=pa_last) *pc++=*pa++; //LB已到达表尾，依次将LA的剩余元素插人LC的最后</span><br><span class="line">while (pb&lt;=pb_las t) *pc++=*pb++; //LA已到达表尾，依次将LB的剩余元素插入LC的最后</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>用链表实现</strong></p>
<p>如果两个表长分别记为m和n，算法的时间复杂度为O(m+ n)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void MergeList_L(LinkList &amp;LA,LinkList &amp;LB,LinkList &amp;LC) </span><br><span class="line">｛／／已知单链表 LA和LB的元素按值非递减排列</span><br><span class="line">//归并LA 和 LB得到新的单链表 LC, LC的元素也按值非递减排列</span><br><span class="line">pa=LA-&gt;next;pb=LB-&gt;next; //pa 和 pb的初值分别指向两个表的第一个结点</span><br><span class="line">LC=LA; ／／用LA的头结点作为LC的头结点</span><br><span class="line">pc=LC; //pc的初值指向LC的头结点</span><br><span class="line">while(pa&amp;&amp;pb) </span><br><span class="line">&#123;//LA 和 LB均未到达表尾，依次 “摘取”两表中值较小的结点插人到LC的最后</span><br><span class="line">if(pa-&gt;data&lt;=pb-&gt;data) //&#x27;摘取&quot;pa所指结点</span><br><span class="line">&#123;</span><br><span class="line">pc-&gt;next=pa; ／／将pa所指结点链接到pc所指结点之后</span><br><span class="line">pc=pa; //pc指向pa</span><br><span class="line">pa=pa-&gt;next; //pa指向下一结点</span><br><span class="line">&#125;</span><br><span class="line">else // &quot;摘取&quot;pb所指结点</span><br><span class="line">&#123;</span><br><span class="line">pc-&gt;next=pb; ／／将pb所指结点链接到pc所指结点之后</span><br><span class="line">pc=pb; //pc指向pb</span><br><span class="line">pb=pb-&gt;next; //pb指向下一结点</span><br><span class="line">&#125;</span><br><span class="line">&#125;//while </span><br><span class="line">pc-&gt;next=pa?pa:pb; ／／将非空表的剩余段插入到pc所指结点之后</span><br><span class="line">delete LB; ／／释放LB的头结点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、栈和队列"><a href="#二、栈和队列" class="headerlink" title="二、栈和队列"></a>二、栈和队列</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="栈的定义和特点"><a href="#栈的定义和特点" class="headerlink" title="栈的定义和特点"></a>栈的定义和特点</h3><p>栈是限定仅在表尾进行插入或删除操作的线性表。表尾端称为栈顶；表头端称为栈底；不含元素的空表称为空栈。</p>
<p>栈又称为<strong>后进先出</strong>的线性表。</p>
<h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/／－－－－－ 顺序栈的存储结构－ －－－－</span><br><span class="line">#define MAXSIZE 100 ／／顺序栈存储空间的初始分配址</span><br><span class="line">typedef struct </span><br><span class="line">&#123;</span><br><span class="line">SElemType *base; ／／栈底指针</span><br><span class="line">SElernType *top; ／／栈顶指针</span><br><span class="line">int stacksize; ／／栈可用的最大容量</span><br><span class="line">&#125;SqStack; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>栈底指针 base 始终指向栈底的位置， 若 base 的值为NULL, 则表明栈结构不存在。</p>
<p>top 为栈顶指针， 其初值指向栈底。 每当 插入新的栈顶元素时， 指针 top 增1; 删除栈顶元素时， 指针 top 减1。</p>
<p>栈空时， top 和 base 的值相等， 都指向栈底。base&#x3D;&#x3D;top</p>
<p>栈满：top-base&#x3D;stacksize</p>
<p>栈长：S.top-S.base</p>
<p>栈非空时， top 始终指向栈顶元素的上一个 位置。</p>
</blockquote>
<p><strong>初始化</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Status InitStack(SqStack &amp;S) </span><br><span class="line">｛／／构造一个空栈s</span><br><span class="line">S.base=new SElemType[MAXSIZE]; ／／为顺序栈动态分配一个最大容量为 MAXSIZE 的数组空间</span><br><span class="line">	//S.base=(SElemType*)malloc(MAXSIZE*sizeof(SElemType))</span><br><span class="line">if (! S. base) exit (OVERFLOW) ; ／／存储分配失败</span><br><span class="line">S.top=S.base;				//top 初始为 base, 空栈</span><br><span class="line">S.stacksize=MAXSIZE; 		//stacksize 置为栈的最大容量 MAXSIZE</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>入栈</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status Push (SqStack &amp;S, SElemType e) </span><br><span class="line">&#123;//插入元素e为新的栈顶元素</span><br><span class="line">if(S.top-S.base==S.stacksize) return ERROR; //栈满</span><br><span class="line">*S.top=e;S.top++;//*S.top++=e; //元素 e 压入栈顶， 栈顶指针加 1</span><br><span class="line">return OK</span><br></pre></td></tr></table></figure>

<p><strong>出栈</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Status Pop(SqStack &amp;S,SElemType &amp;e) </span><br><span class="line">&#123;//若栈不为空，删除s的栈顶元素， 用 e 返回其值</span><br><span class="line">if(S.top==S.base) return ERROR; //等价于if(StackEmpty(S))／／栈空</span><br><span class="line">--S.top;e=*S.top;//e=*--S.top;／／栈顶指针减 1, 将栈顶元素赋给e</span><br><span class="line">return OK; </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>取栈顶元素</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SElemType GetTop&#123;SqStack S) </span><br><span class="line">｛／／返回 s 的栈顶元素， 不修改栈顶指针</span><br><span class="line">if(S.top! =S.base) ／／栈非空</span><br><span class="line">return *&#123;S.top-1); ／／返回栈顶元素的值，栈顶指针不变</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h3><p>以链表的头部作 为栈顶是最方便的， 而且没必要像单链表那样为了操作方便附加一 个头结点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">／／－－－－－ 链栈的存储结构－－－－－</span><br><span class="line">typedef struct StackNode </span><br><span class="line">&#123;</span><br><span class="line">ElemType data; </span><br><span class="line">struct StackNode *next; </span><br><span class="line">&#125; StackNode,*LinkStack;</span><br></pre></td></tr></table></figure>

<p><strong>初始化</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status InitStack(LinkStack &amp;S) </span><br><span class="line">&#123;//构造一个空栈 s, 栈顶指针置空</span><br><span class="line">S=NULL; </span><br><span class="line">return OK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>入栈</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status Push(LinkStack &amp;S, SElemType e) </span><br><span class="line">｛／／在栈顶插入元素e</span><br><span class="line">p=new StackNode; ／／生成新结点</span><br><span class="line">p-&gt;data=e; ／／将新结点数据域置为e</span><br><span class="line">p-&gt;next=S; ／／将新结点插人栈顶</span><br><span class="line">S=p; ／／修改栈顶指针为p</span><br><span class="line">return OK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>出栈</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Status Pop(LinkStack &amp;S,SElemType &amp;e) </span><br><span class="line">｛／／删除 s 的栈顶元素，用 e 返回其值</span><br><span class="line">if(S==NULL) return ERROR; ／／栈空</span><br><span class="line">e=S-&gt;data; ／／将栈顶元素赋给 e</span><br><span class="line">p=S; ／／用 p 临时保存栈顶元素空间， 以备释放</span><br><span class="line">S=S-&gt;next; ／／修改栈顶指针</span><br><span class="line">delete p; ／／释放原栈顶元素的空间</span><br><span class="line">return OK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>取栈顶元素</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SElemType GetTop(LinkStack S) </span><br><span class="line">｛／／返回 s 的栈顶元素， 不修改栈顶指针</span><br><span class="line">if(S! =NULL) //栈非空</span><br><span class="line">return S-&gt;data; ／／返回栈顶元素的值，栈顶指针不变</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="栈和递归"><a href="#栈和递归" class="headerlink" title="栈和递归"></a>栈和递归</h3><p><strong>递归的优缺点</strong></p>
<p>优点：结构清晰，程序易读</p>
<p>缺点：每次调用要生成工作记录，保存状态信息，入栈；返回时要出栈，恢复状态信息。时间开销大。</p>
<p><strong>递归   ———&gt;   非递归</strong></p>
<p>方法1：尾递归、单向递归  ——&gt; 循环结构</p>
<p>方法2：自用栈模拟系统的运行时栈</p>
<p>尾递归——-&gt;循环结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">long Fact(long n)&#123;</span><br><span class="line">if(n==0)return 1;</span><br><span class="line">else return n*Fact(n-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">long Fact(long n)&#123;</span><br><span class="line">t=1;</span><br><span class="line">for(i=1;i&lt;=n;i++) t=t*i;</span><br><span class="line">return t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="队列的定义和特点"><a href="#队列的定义和特点" class="headerlink" title="队列的定义和特点"></a>队列的定义和特点</h3><p>队列只允许在表 的一端进行插入，而在另一端删除元素。允许插入的一端称为队尾；允许 删除的一端则称为队头。</p>
<p>头指针始终指向队列头元素，而尾指针始终指向队列尾元素的下一个位置</p>
<p>队列是一种<strong>先进先出</strong>的线性表。</p>
<h3 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">／／ －－－－－ 队列的顺序存储结构－－－－－</span><br><span class="line">#define MAXQSIZE 100 ／／队列可能达到的最大长度</span><br><span class="line">typedef struct </span><br><span class="line">&#123; </span><br><span class="line">QElemType *base; ／／存储空间的基地址</span><br><span class="line">int front; //头指针</span><br><span class="line">int rear; ／／尾指针</span><br><span class="line">&#125; SqQueue; </span><br></pre></td></tr></table></figure>

<p>每当插入 新的队列尾元素时，尾指针 rear增1; 每当删除队列头元素时， 头指针 front增1。</p>
<p><strong>如何区别循环队列是队空还是队满</strong></p>
<p>少用一个元素空间， 即队列空间大小为m时，有m-1个元素就认为是队满。</p>
<p>当头、 尾指针的值相同时， 则认为队空。</p>
<p>当尾指针在循环意义上加1后是等 于头指针， 则认为队满。</p>
<blockquote>
<p>队空的条件： Q.front &#x3D; Q.rear </p>
<p>队满的条件： (Q .rear+ 1)%MAXQSIZE &#x3D; Q.front</p>
</blockquote>
<p><strong>顺序队列的初始化</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Status InitQueue (SqQueue &amp;Q) </span><br><span class="line">&#123;//构造一个空队列Q</span><br><span class="line">Q.base=new QElemType[MAXQSIZE]／／为队列分配一个最大容扯为 MAXQSIZE 的数组空间</span><br><span class="line">if(!Q.base) exit(OVERFLOW);／／存储分配失败</span><br><span class="line">Q.front=Q.rear=O;//头指针和尾指针置为零， 队列为空</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>求循环队列长度</strong></p>
<p>非循环队列，尾指针和头指针的差值便是队列长度。</p>
<p>对于循环队列，差值可能为负数， 所以需要将差值加上MAXQSIZE, 然后与MAXQSIZE求余</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int QueueLength(SqQueue Q) </span><br><span class="line">&#123;／／返回Q的元素个数， 即队列的长度</span><br><span class="line">return (Q.rear-Q.front+MAXQSIZE)%MAXQSIZE; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>循环队列入队</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status EnQueue (SqQueue &amp;Q, QElemType e) </span><br><span class="line">｛／／插入元素 e 为 Q 的新的队尾元素</span><br><span class="line">if ((Q.rear+l) %MAXQSIZE==Q. fron))／／尾指针在循环意义上加1后等于头指针， 表明队满</span><br><span class="line">return ERROR; </span><br><span class="line">Q.base[Q.rear]=e;／／新元素插入队尾</span><br><span class="line">Q.rear=(Q.rear+l)%MAXQSIZE;／／队尾指针加1</span><br><span class="line">return OK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>循环队列出队</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Status DeQueue (SqQueue &amp;Q, QElemType &amp;e) </span><br><span class="line">｛／／删除Q的队头元素， 用 e 返回其值</span><br><span class="line">if(Q.front==Q. rear) return ERROR; / /队空</span><br><span class="line">e=Q.base[Q.front]; //保存队头元素</span><br><span class="line">Q.front=(Q.front+l)%MAXQSIZE; //队头指针加1</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>取循环队列的队头元素</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SElemType GetHead(SqQueue Q) </span><br><span class="line">｛／／返回Q的队头元素，不修改队头指针</span><br><span class="line">if(Q. front! =Q. rear) ／／队列非空</span><br><span class="line">return Q.base[Q.front]; ／／返回队头元素的值，队头指针不变</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链队列"><a href="#链队列" class="headerlink" title="链队列"></a>链队列</h3><p><img src="https://hakaimg.com/i/2022/11/27/qwxyyp.png"></p>
<p>为了操作方便起见，给链队添加一个头结点， 并令头指针始 终指向头结点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">／／－－－－－ 队列的链式存储结构－－－－－</span><br><span class="line">typedef struct QNode</span><br><span class="line">&#123;</span><br><span class="line">	QElemType data; </span><br><span class="line">	struct QNode *next; </span><br><span class="line">&#125;QNode, *QueuePtr; </span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123; </span><br><span class="line">QueuePtr front; ／／队头指针</span><br><span class="line">QueuePtr rear; ／／队尾指针</span><br><span class="line">) LinkQueue; </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>初始化</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Status InitQueue (LinkQueue &amp;Q) </span><br><span class="line">&#123;／／构造一个空队列 Q</span><br><span class="line">Q.front=Q.rear=new QNode;／／生成新结点作为头结点，队头和队尾指针指向此结点</span><br><span class="line">Q.front-&gt;next=NULL;／／头结点的指针域置空</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>链队列的入队</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status EnQueue (LinkQueue &amp;Q, QElemType e) </span><br><span class="line">&#123;//插入元素e为Q的新的队尾元素</span><br><span class="line">p=new QNode; //为入队元素分配结点空间，用指针p指向</span><br><span class="line">p-&gt;data=e; //将新结点数据域置为e</span><br><span class="line">p-&gt;next=NULL; Q.rear-&gt;next=p; //将新结点插入到队尾</span><br><span class="line">Q.rear=p; //修改队尾指针</span><br><span class="line">return OK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>链队的出队</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Status DeQueue(LinkQueue &amp;Q,QElemType &amp;e) </span><br><span class="line">｛／／删除Q的队头元素， 用e返回其值</span><br><span class="line">if(Q.front==Q.rear) return ERROR; ／／若队列空， 则返回 ERROR</span><br><span class="line">p=Q.front-&gt;next; //p指向队头元素</span><br><span class="line">e=p-&gt;data; //e保存队头元素的值</span><br><span class="line">Q.front-&gt;next=p-&gt;next;／／修改头指针</span><br><span class="line">if(Q.rear==p) Q.rear=Q.front; ／／最后一个元素被删， 队尾指针指向头结点</span><br><span class="line">delete p; ／／释放原队头元素的空间</span><br><span class="line">return OK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>取链队的队头元素</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SElemType GetHead&#123;LinkQueue Q) </span><br><span class="line">&#123;//返回Q的队头元素， 不修改队头指针</span><br><span class="line">if(Q.front!=Q.rear) ／／队列非空</span><br><span class="line">return Q.front-&gt;next-&gt;data; ／／返回队头元素的值，队头指针不变</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="三、串、数组和广义表"><a href="#三、串、数组和广义表" class="headerlink" title="三、串、数组和广义表"></a>三、串、数组和广义表</h1><h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><h3 id="串的类型定义、存储结构"><a href="#串的类型定义、存储结构" class="headerlink" title="串的类型定义、存储结构"></a>串的类型定义、存储结构</h3><p>串(string)(或字符串）是由零个或多个字符组成的有限序列</p>
<p><strong>串的顺序存储</strong></p>
<p>算法描述当中所用到的顺序存储的字符串都是从下标为1的数组分量开始存储的， 下标为0的分量闲置不用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">／／－－－－－ 串的定长顺序存储结构－ － －－－</span><br><span class="line">#define MAXLEN 255 ／／串的最大长度</span><br><span class="line">typedef struct &#123; </span><br><span class="line">char ch[MAXLEN+l]; ／／存储串的一维数组</span><br><span class="line">int length; ／／串的当前长度</span><br><span class="line">&#125; SString; </span><br></pre></td></tr></table></figure>

<p>在C语言中， 存在一个称之为 ＂堆” (Heap)的自由存储区， 可以 为每个新产生的串<strong>动态分配</strong>一块实际串长所需的存储空间， 若分配成功， 则返回一个指向起始 地址的指针， 作为串的基址， 同时为了以后处理方便， 约定串长也作为存储结构的一部分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">／／－－－－－ 串的堆式顺序存储结构－－－－ －</span><br><span class="line">typedef struct&#123; </span><br><span class="line">char *ch; ／／若是非空串， 则按串长分配存储区， 否则 ch 为 NULL</span><br><span class="line">int length; ／／串的当前长度</span><br><span class="line">&#125;HString; </span><br></pre></td></tr></table></figure>

<p><strong>串的链式存储</strong></p>
<p><img src="https://hakaimg.com/i/2022/11/27/r4ql7l.png"></p>
<p>当以链表存储串值时，除头指针外， 还可附设一个尾指针指示链表中的最后一个结点，并给出当前串的长度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">／／－－－－－ 串的链式存储结构－ － －－－</span><br><span class="line">#define CHUNKSIZE 80 //可由用户定义的块大小</span><br><span class="line">typedef struct Chunk&#123; </span><br><span class="line">char ch [ CHUNKSIZE」;</span><br><span class="line">struct Chunk *next; </span><br><span class="line">&#125; Chunk; </span><br><span class="line"></span><br><span class="line">typedef struct&#123; </span><br><span class="line">Chunk *head,*tail; ／／串的头和尾指针</span><br><span class="line">int length; ／／串的当前长度</span><br><span class="line">&#125; LString; </span><br></pre></td></tr></table></figure>

<h3 id="串的算法——BF算法"><a href="#串的算法——BF算法" class="headerlink" title="串的算法——BF算法"></a>串的算法——BF算法</h3><p>主串的长度为n, 子串的长度为m</p>
<p>最好情况下的平均时间复杂度是 O(n + m)</p>
<p>最坏情况下的平均时间复杂度是 O(n x m)</p>
<p>串的模式匹配设有两个字符串S和T, 设S为主串，也称正文串；设T为子串，也称为模式。</p>
<p>在主串S中查找与模式T相匹配的子串，如果匹配成功， 确定相匹配的子串中的<strong>第一个</strong>字符在主 串S中出现的位置。</p>
<p>思路：从主串的每一个字符开始依次与子串的字符进行匹配。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int Index_BF(SString S,SString T,int pos&#125; </span><br><span class="line">｛／／返回模式T在主串s中第pos个字符开始第一次出现的位置。若不存在， 则返回值为0</span><br><span class="line">／／其中，T非空，1&lt;=pos&lt;=s.length</span><br><span class="line">i=pos; j=l; //初始化</span><br><span class="line">while (i &lt; =S. length &amp;&amp; j &lt; =T. length) / /两个串均未比较到串尾</span><br><span class="line">&#123;</span><br><span class="line">if(S[i].ch==T[j] .ch) &#123;++i;++j;&#125; //主串和子串依次匹配下一个字符</span><br><span class="line">else&#123;i=i-j+2;j=l;&#125; //主串子串指针回溯重新开始下一次匹配</span><br><span class="line">&#125;</span><br><span class="line">if (j &gt; T. length) return i-T. length; //返回匹配的第一个字符的下标</span><br><span class="line">else return O; //匹配失败</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在指针回溯的时候，子串的直接回溯回1，主串的需要回溯到i-j+2</p>
<p>可以看成是i-j+1+1 ;  i-j+i是i回退到最开始的位置，再+1是因为要从下一个开始</p>
<p>成功返回的第一个字符的下标是 i-T.length</p>
</blockquote>
<h3 id="串的算法——KMP算法"><a href="#串的算法——KMP算法" class="headerlink" title="串的算法——KMP算法"></a>串的算法——KMP算法</h3><p>可以在 O(n + m)的时间数量级上完成串的模式匹配操作</p>
<p>不需回溯 i 指针;  j 需要回到的位置为next[j];</p>
<p>next[j]]表明当模式中第j 个字符与主串中相应字符 ＂失配” 时，在模 式中需重新和主串中该字符进行比较的字符的位置</p>
<p><img src="https://hakaimg.com/i/2022/11/27/sd3hvt.png"></p>
<p><img src="https://hakaimg.com/i/2022/11/27/sgb0v8.png"></p>
<p><strong>next值的计算</strong></p>
<p>在这个例子中，j&#x3D;15的时候是d,从头开始的有6个元素与j前面的6个元素相等，所以k-1&#x3D;6—-&gt;k&#x3D;7</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int Index_KMP(SString S,SString T,int pos)</span><br><span class="line">&#123;//利用模式串 T 的 next 函数求 T 在主串 S 中第 pos 个字符之后的位置</span><br><span class="line">／／其中，T非空， 1&lt;=pos&lt;=s.length </span><br><span class="line">i=pos;j=1; </span><br><span class="line">while (i &lt; =S.length &amp;&amp; j &lt; =S.length)／／两个串均未比较到串尾</span><br><span class="line">&#123; </span><br><span class="line">if ( j == 0 || s [ i ] ==T [ j ] )&#123; ++ i ; ++ j ; &#125; ／／继续比较后继字符</span><br><span class="line">else j=next[j]; ／／模式串向右移动</span><br><span class="line">if (j &gt; T [0]) return i-T [0] ; ／／匹配成功</span><br><span class="line">else return 0; ／／匹配失败</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void get_next(SString T,int next[]) </span><br><span class="line">&#123;//求模式串 T的 next 函数值并存入数组 next</span><br><span class="line">i=1;next[1]=0;j=0; </span><br><span class="line">while (i &lt;=T.length) </span><br><span class="line">&#123;</span><br><span class="line">if(j==0 || T[i]==T[j]) &#123;++i;++j;next[i]=j; &#125; </span><br><span class="line">else j=next[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>nextval的计算</strong></p>
<p><img src="https://hakaimg.com/i/2022/11/27/u8emdv.png"></p>
<p>next值是几，就和第几位进行比较，若相同，则与该位的next值所示的新的元素进行比较，若不同，则nextval值为前一个元素的next值，若不同，则nextval的值就为自己的next值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void get_nextval(SString T, int nextval[]) </span><br><span class="line">&#123;／／求模式串 T 的 next 函数修正值并存入数组 nextval</span><br><span class="line">i=l;nextval[1] =0; j=0; </span><br><span class="line">while(i&lt;T.length) </span><br><span class="line">&#123;</span><br><span class="line">if (j==0 || T [i] ==T [j])</span><br><span class="line">	&#123;</span><br><span class="line">		++i;++j; </span><br><span class="line">		if(T[i] !=T[j]) nextval[i]=j; </span><br><span class="line">		else nextval [i] =nextval [ j] ;</span><br><span class="line">	&#125;</span><br><span class="line">else j=nextval[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组的定义及特点"><a href="#数组的定义及特点" class="headerlink" title="数组的定义及特点"></a>数组的定义及特点</h3><p>数组是由类型相同的数据元素构成的有序集合。</p>
<p>特点：数组一旦被定义， 它的维数和维界就不再改变。除了结构的初始化和销毁之外， 数组 只有存取元素和修改元素值的操作。</p>
<p>一维数组可以看成是一个线性表，二维数组可以看成数据元素是线性表的线性表。一个 n 维数组类型可以定义为其数据元素为 n-1维数组类型的一维数组类型。</p>
<h3 id="数组的顺序存储"><a href="#数组的顺序存储" class="headerlink" title="数组的顺序存储"></a>数组的顺序存储</h3><p>一维数组：</p>
<p><img src="https://hakaimg.com/i/2022/11/28/fpbrsq.png"></p>
<p>二维数组：</p>
<p>以行序为主序</p>
<p><img src="https://hakaimg.com/i/2022/11/28/ftdtxk.png"></p>
<p>三维数组：</p>
<p>m1:表示在第几页、m2:表示在第几行、 m3：表示在第几列</p>
<p><img src="https://hakaimg.com/i/2022/11/28/gjzj6w.png"></p>
<h3 id="特殊矩阵压缩存储（对称、三角、对角、稀疏）"><a href="#特殊矩阵压缩存储（对称、三角、对角、稀疏）" class="headerlink" title="特殊矩阵压缩存储（对称、三角、对角、稀疏）"></a>特殊矩阵压缩存储（对称、三角、对角、稀疏）</h3><p>为多个相同的非零元素只分配一个存储空间；对零元素不分配空间</p>
<p><strong>对称矩阵</strong></p>
<p><img src="https://hakaimg.com/i/2022/11/28/h2naoa.png"></p>
<p><img src="https://hakaimg.com/i/2022/11/28/h6ahn1.png"></p>
<p><strong>三角矩阵</strong></p>
<p>三角矩阵有上三角矩阵和下三角矩阵两种。</p>
<p>上三角矩阵是指矩阵下三角（不包括对角线）中的元均为常数c或零的n阶矩阵， 下三角矩阵与之相反。</p>
<p>除了和对称矩阵一样， 只存储其上 （下）兰角中的元素之外， 再加一个存储常数c的存储 空间即可。</p>
<p><img src="https://hakaimg.com/i/2022/11/28/h9p98w.png"></p>
<p>下三角矩阵</p>
<p><img src="https://hakaimg.com/i/2022/11/28/h9v7kk.png"></p>
<p><strong>对角矩阵</strong></p>
<p>所有的非零元都集中在以主对角线为中心的带状区域中，即除了主对角线上 和直接在对角线上、下方若干条对角线上的元之外，所有其他的元皆为零</p>
<p><img src="https://hakaimg.com/i/2022/11/28/hckmix.png"></p>
<p><strong>稀疏矩阵</strong></p>
<p><img src="https://hakaimg.com/i/2022/11/28/hflqn7.png"></p>
<p>三元组顺序表的优点：非零元在表中按行序有序存储，因此便于进行依行顺序处理的矩阵运算。</p>
<p>缺点：不能随机存取。若按行号存取某一行中的非零元，则需从头开始进行查找。</p>
<p><img src="https://hakaimg.com/i/2022/11/28/i73bbv.png"></p>
<h2 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h2><h3 id="广义表的性质"><a href="#广义表的性质" class="headerlink" title="广义表的性质"></a>广义表的性质</h3><p>广义表是线性表的推广，也称为列表，是n个元素的有限序列，其中每一个ai或者是原子，或者是一个广义表。</p>
<p>表头：第一个元素a1就是表头</p>
<p>表尾：除表头外的其他元素组成的表，表尾不是最后一个元素，而是一个子表</p>
<p><img src="https://hakaimg.com/i/2022/11/28/id085l.png"></p>
<p><img src="https://hakaimg.com/i/2022/11/28/ifj72f.png"></p>
<p>(1·) 取表头 GetHead(LS): 取出的表头为非空广义表的第一个元素，它可以是一个单原子，也 可以是一个子表</p>
<p>(2) 取表尾 GetTail(LS): 取出的表尾为除去表头之外，由其余元素构成的表。即表尾一定是 一个广义表。</p>
<p><img src="https://hakaimg.com/i/2022/11/28/iicrmf.png"></p>
<h1 id="四、树和二叉树"><a href="#四、树和二叉树" class="headerlink" title="四、树和二叉树"></a>四、树和二叉树</h1><h2 id="树的定义与基本术语"><a href="#树的定义与基本术语" class="headerlink" title="树的定义与基本术语"></a>树的定义与基本术语</h2><p>树是n个结点的有限集，有且仅有一个根结点。</p>
<ul>
<li>结点：树中的一个独立单元。包含一个数据元素及若于指向其子树的分支</li>
<li>结点的度：结点拥有的子树数称为结点的度</li>
<li>树的度：树的度是树内各结点度的最大值</li>
<li>叶子： 度为 0 的结点称为叶子或终端结点</li>
<li>非终端结点：度不为 0 的结点称为非终端结点或分支结点</li>
<li>双亲和孩子：结点的子树的根称为该结点的孩子，相应地，该结点称为孩子的双亲</li>
<li>兄弟：同一个双亲的孩子之间互称兄弟</li>
<li>祖先：从根到该结点所经分支上的所有结点</li>
<li>子孙：以某结点为根的子树中的任一结点都称为该结点的子孙</li>
<li>层次：结点的层次从根开始定义起，根为 第一层，根的孩子为第二层。树中任一结点的 层次等千其双亲结点的层次加 1。</li>
<li>堂兄弟：双亲在同 一层的结点互为堂兄弟</li>
<li>树的深度：树中结点的最大层次称为树的深度或高度</li>
<li>有序树和无序树：如果将树中结点的各子树看成从左至右是有次序的（即不能互换）， 则称该树为有序树，否则称为无序树。在有序树中最左边的子树的根称为第一个孩子，最右边的 称为最后一个孩子</li>
<li>森林：是 m (m&gt;0)棵互不相交的树的集合。对树中每个结点而言，其子树的集合即 为森林</li>
</ul>
<h2 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h2><p>二叉树的递归定义表明二叉树或为空或是由一个根结点加上两棵分别称为左子树和右子树 的、互不相交的二叉树组成。</p>
<p>二叉树每个结点至多只有两棵子树</p>
<p>二叉树的子树有左右之分，其次序不能任意颠倒</p>
<p>二叉树就算只有一个结点，也要指明是左子树还是右子树，而树就不需要区分左右次序。</p>
<h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><p><strong>性质1</strong> 	在二叉树的 第i层上至多有2^(i-1) 个结点（i&gt;&#x3D;1)，至少有1个结点。</p>
<p><strong>性质2</strong> 	深度为K的 二叉树至多有 2^k -1 个结点 (k&gt;&#x3D;1)，至少有k个结点。</p>
<p><strong>性质3</strong> 	对任何一棵二叉树T, 如果其终端结点数为n0，度为2的结点数为n2,则n0 &#x3D; n2+1</p>
<p><strong>满二叉树</strong>	</p>
<p>深度为 K且含有2 ^k-1个结点的二叉树</p>
<p>特点：每层都满、叶子结点全在最底层</p>
<p>编号规则：从根结点开始，从上而下、从左而右</p>
<p><img src="https://hakaimg.com/i/2022/11/28/prv50z.png"></p>
<p><strong>完全二叉树</strong></p>
<p>深度为K的， 有n个结点的二叉树， 当且仅当其每一个结点都与深度为K的满 二叉树中编号从1至n的结点一一对应时， 称之为完全二叉树</p>
<p>特点：叶子结点只可能在层次最大的两层上出现、对任一结点， 若右子树最大层次为l, 则其左子树最大层次必 为 l 或 l+ 1。</p>
<p><img src="https://hakaimg.com/i/2022/11/28/qj6bu0.png"></p>
<p><strong>性质 4</strong> 	具有 n 个结点的完全二叉树的深度为llog2n|+ 1 。</p>
<p><strong>性质 5</strong> 	描述双亲结点编号与孩子结点编号之间的关系</p>
<p>如果对一棵有 n个结点的完全二叉树（其深度为Llog2n」+ 1) 的结点按层序编号（从 第 1 层到第llog2n」+ 1 层， 每层从左到右）， 则对任一结点i（1&lt;&#x3D;i&lt;&#x3D;n), 有</p>
<p>(1)如果i &#x3D; 1, 则结点l是二叉树的根，无双亲；如果i&gt; 1, 则其双亲PARENT(i )是结 点Li&#x2F;2」</p>
<p>( 2 )如果2i&gt;n, 则结点i无左孩子（结点i为叶子结点）；否则其左孩子LCHILD(i)是结点 2i</p>
<p>(3)如果2i+1&gt;n, 则结点i无右孩子；否则其右孩子RCHILD(i )是结点2i+l。</p>
<h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><p><strong>顺序存储结构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//-----二叉树的顺序存储表示－－－－－</span><br><span class="line">#define MAXTSIZE 100 ／／二叉树的最大结点数</span><br><span class="line">typedef TElemType SqBiTree[MAXTSIZE]; //0 号单元存储根结点</span><br><span class="line">SqBiTree bt; </span><br></pre></td></tr></table></figure>

<p><img src="https://hakaimg.com/i/2022/11/28/qqsogu.png"></p>
<p><strong>链式存储结构</strong></p>
<p>表示二叉树的链表 中的结点至少包含 3 个域：数据域和左、 右指针域，有时，为了便于找到结 点的双亲，还可在结点结构中增加一个指向其双亲结点的指针域，链表的头指 针指向二叉树的根结点</p>
<p>在含有 n个结点的二叉链表中有 n+l 个空链域</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//- - - - -二叉树的二叉链表存储表示－ －－－－</span><br><span class="line">typedef struct BiTNode&#123; </span><br><span class="line">TElemType data; ／／结点数据域</span><br><span class="line">struct BiTNode *lchild,*rchild; ／／左右孩子指针</span><br><span class="line">&#125; BiTNode,*BiTree; </span><br></pre></td></tr></table></figure>

<h2 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h2><p>三种遍历算法的时间效率是O(n)、空间效率是O(n)</p>
<p><img src="https://hakaimg.com/i/2022/11/28/qw9gjd.png"></p>
<p><img src="https://hakaimg.com/i/2022/11/28/qy2cz0.png"></p>
<p><strong>由遍历序列确定二叉树</strong></p>
<p>由二叉树的<strong>先序</strong>序列和<strong>中序</strong>序列，或由 其<strong>后序</strong>序列和<strong>中序</strong>序列均能唯一地<strong>确定一棵二叉树。</strong></p>
<p><img src="https://hakaimg.com/i/2022/11/28/r56xqm.png"></p>
<p><img src="https://hakaimg.com/i/2022/11/28/r68fg2.png"></p>
<h3 id="先序遍历算法"><a href="#先序遍历算法" class="headerlink" title="先序遍历算法"></a>先序遍历算法</h3><p><img src="https://hakaimg.com/i/2022/11/28/r8ve4k.png"></p>
<h3 id="中序遍历算法"><a href="#中序遍历算法" class="headerlink" title="中序遍历算法"></a>中序遍历算法</h3><p><strong>递归算法</strong></p>
<img src="https://hakaimg.com/i/2022/11/28/7l7nagi.png" style="zoom:150%;" />

<p><strong>非递归算法</strong></p>
<p><img src="https://hakaimg.com/i/2022/11/28/s6lnsj.png"></p>
<h3 id="后序遍历算法"><a href="#后序遍历算法" class="headerlink" title="后序遍历算法"></a>后序遍历算法</h3><img src="https://hakaimg.com/i/2022/11/28/rbsfpk.png" style="zoom:80%;" />

<h3 id="层次遍历算法"><a href="#层次遍历算法" class="headerlink" title="层次遍历算法"></a>层次遍历算法</h3><p>对于一颗二叉树，从根结点开始，按从上到下、从左到右的顺序访问每一个结点，每个节点仅仅访问一次。</p>
<p>根结点先进队，然后左孩子进队、右孩子进队、左孩子的左孩子进队、左孩子的右孩子进队……..</p>
<p><img src="https://hakaimg.com/i/2022/11/28/s9o6c6.png"></p>
<h2 id="遍历算法的应用"><a href="#遍历算法的应用" class="headerlink" title="遍历算法的应用"></a>遍历算法的应用</h2><h3 id="二叉树的建立"><a href="#二叉树的建立" class="headerlink" title="二叉树的建立"></a>二叉树的建立</h3><p><img src="https://hakaimg.com/i/2022/11/28/7wb0v4y.png"></p>
<h3 id="复制二叉树"><a href="#复制二叉树" class="headerlink" title="复制二叉树"></a>复制二叉树</h3><p><img src="https://hakaimg.com/i/2022/11/28/skw65x.png"></p>
<h3 id="计算二叉树的深度"><a href="#计算二叉树的深度" class="headerlink" title="计算二叉树的深度"></a>计算二叉树的深度</h3><p>二叉树的深度为树中结点的最大层次， 二叉树的深度为左右子树深度的较大者加1。</p>
<p><img src="https://hakaimg.com/i/2022/11/28/smod0v.png"></p>
<h3 id="计算二叉树结点总数"><a href="#计算二叉树结点总数" class="headerlink" title="计算二叉树结点总数"></a>计算二叉树结点总数</h3><p><img src="https://hakaimg.com/i/2022/11/28/soh8f8.png"></p>
<h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p>这里的”前驱“、”后继“指的是在遍历序列中的顺序</p>
<p>如：中序遍历为CBEGDFA,   A的前驱为F。B的后继为E</p>
<p>如果某个结点的<strong>左孩子为空</strong>，则将空的左孩子指针域改为<strong>指向其前驱</strong>；</p>
<p>如果某个结点的<strong>右孩子为空</strong>，则将空的右孩子指针域改为<strong>指向其后继</strong>；</p>
<p><img src="https://hakaimg.com/i/2022/11/28/81byhx7.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//- - - - -二叉树的二叉线索存储表示－ －－－－</span><br><span class="line">typedef struct BiThrNode </span><br><span class="line">&#123; </span><br><span class="line">TElemType data; </span><br><span class="line">struct BiThrNode *lchild,*rchild; //左右孩子指针</span><br><span class="line">int LTag, RTag; //左右标志</span><br><span class="line">&#125; BiThrNode,*BiThrTree;</span><br></pre></td></tr></table></figure>

<p><img src="https://hakaimg.com/i/2022/11/28/t0jg0v.png"></p>
<p><img src="https://hakaimg.com/i/2022/11/28/t0mzyn.png"></p>
<p>为了避免遍历结果中第一个元素它没有前驱，所以它的指向前驱的指针悬空，最后一个元素没有后继，所以它的指向后继的指针悬空，因此增设了一个头结点</p>
<p><img src="https://hakaimg.com/i/2022/11/28/tsjcxr.png"></p>
<h2 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h2><h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3><p>以一组连续的存储单元存储树的结点，每个结点除了数据域data外，还附设一个parent域用以指示其双亲结点的位置</p>
<p>利用了每个结点（除根以外）只有唯一的双亲的性质。</p>
<p>在这种存储结构下， <strong>求结点的双亲十分方便</strong>，也很容易求树的根，但<strong>求结点的孩子时不方便</strong>需要遍历整个结构</p>
<p><img src="https://hakaimg.com/i/2022/11/28/8awdrah.png"></p>
<h3 id="孩子链表"><a href="#孩子链表" class="headerlink" title="孩子链表"></a>孩子链表</h3><p>语言叙述感觉有点别扭，一个图解决一切！</p>
<p>用孩子链表查找孩子快，查找双亲慢</p>
<p>用带双亲的孩子链表查找孩子快，查找双亲也快</p>
<p><img src="https://hakaimg.com/i/2022/11/28/tz2wha.png"></p>
<h3 id="孩子兄弟法"><a href="#孩子兄弟法" class="headerlink" title="孩子兄弟法"></a>孩子兄弟法</h3><p>又称二叉树表示法，或二叉链表表示法，即以二叉链表做树的存储结构。</p>
<p>链表中结点的两个 链域分别指向该结点的第一个孩子结点和下一个兄弟结点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//- - - - - -树的二叉链表（孩子－兄弟）存储表示－－－－－</span><br><span class="line">typedef struct CSNode&#123;</span><br><span class="line">ElemType data; </span><br><span class="line">struct CSNode *firstchild, *nextsibling; </span><br><span class="line">&#125; CSNode,*CSTree;</span><br></pre></td></tr></table></figure>

<p><img src="https://hakaimg.com/i/2022/11/28/u1xyks.png"></p>
<h2 id="树与二叉树的转换"><a href="#树与二叉树的转换" class="headerlink" title="树与二叉树的转换"></a>树与二叉树的转换</h2><h3 id="树转化为二叉树"><a href="#树转化为二叉树" class="headerlink" title="树转化为二叉树"></a>树转化为二叉树</h3><p>1  加线：在兄弟之间加一连线</p>
<p>2  抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系</p>
<p>3  旋转：以树的根结点为轴心，将整树顺时针旋转45°</p>
<p><strong>树变二叉树:兄弟相连留长子</strong></p>
<h3 id="二叉树转化为树"><a href="#二叉树转化为树" class="headerlink" title="二叉树转化为树"></a>二叉树转化为树</h3><p>1  加线：p是双亲的左孩子，则找到p的右孩子、右孩子的右孩子……沿分支找到所有的右孩子，都与p的双亲用线相连</p>
<p>2  抹线：抹掉原二叉树中双亲与右孩子之间的连线</p>
<p>3  调整：将结点按层次排列，形成树结构</p>
<p><strong>二叉树变树：左孩右右连双亲，去掉原来右孩线</strong></p>
<h2 id="森林与二叉树的转换"><a href="#森林与二叉树的转换" class="headerlink" title="森林与二叉树的转换"></a>森林与二叉树的转换</h2><h3 id="森林转化为二叉树"><a href="#森林转化为二叉树" class="headerlink" title="森林转化为二叉树"></a>森林转化为二叉树</h3><p>1、将各棵树分别转换成二叉树</p>
<p>2、将每棵树的根结点用线相连</p>
<p>3、以第一棵树根结点为二叉树的根，再以根结点为轴心，顺时针旋转，构成二叉树型结构</p>
<p><strong>森林变二叉树：树变二叉根相连</strong></p>
<h3 id="二叉树转换为森林"><a href="#二叉树转换为森林" class="headerlink" title="二叉树转换为森林"></a><strong>二叉树转换为森林</strong></h3><p>1  抹线：将二叉树中根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树</p>
<p>2  还原：将孤立的二叉树还原为树</p>
<p><strong>二叉树变森林：去掉全部右孩线，孤立二叉再还原</strong></p>
<h2 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h2><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><p>一种是<strong>先根</strong>遍历，即先访问树的根结点，然后依次先根遍历根的每棵子树；</p>
<p>一种是<strong>后根</strong>遍历，即先依次后根遍历每 棵子树，然后访问根结点。</p>
<p>一种是<strong>层次</strong>遍历，即自上而下，自左而右访问树的每一个结点。</p>
<h3 id="森林的遍历"><a href="#森林的遍历" class="headerlink" title="森林的遍历"></a>森林的遍历</h3><p>把森林看作三部分</p>
<p>1、森林中第一棵树的根结点</p>
<p>2、森林中第一棵树的子树森林</p>
<p>3、森林中其它树构成的森林</p>
<p><strong>先序遍历</strong>：1、2、3；即依次对森林中的每一棵树进行先根遍历</p>
<p><strong>中序遍历</strong>：2、1、3；即依次从左到右对森林中的每一棵树进行后序遍历</p>
<p><img src="https://hakaimg.com/i/2022/11/29/f1ahqs.png"></p>
<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>哈夫曼(Huffman)树又称最优二叉树，是一类<strong>带权路径长度最短的树</strong>，又称最优二叉树。</p>
<p>路径：从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径</p>
<p>路径长度：路径上的分支数目称作路径长度</p>
<p>树的路径长度：从树根到每一结点的路径<strong>长度之和</strong>。</p>
<p>权：赋予某个实体的一个量，是对实体的某个或某些属性的数值化描述</p>
<p>结点的带权路径长度：从该结点到树根之间的<strong>路径长度</strong>与结点上<strong>权</strong>的<strong>乘积</strong>。</p>
<p>树的带权路径长度（WPL）：树中所有叶子结点的带权路径长度之和</p>
<p><strong>特点：</strong></p>
<p>满二叉树不一定是哈夫曼树、哈夫曼树中权越大的叶子结点离根越近、具有相同带权结点的哈夫曼树不唯一</p>
<h3 id="哈夫曼树的构造算法"><a href="#哈夫曼树的构造算法" class="headerlink" title="哈夫曼树的构造算法"></a>哈夫曼树的构造算法</h3><p><strong>贪心算法</strong>：构造哈夫曼树时首先选择权值小的叶子结点</p>
<p><strong>口诀：</strong></p>
<p>1、<strong>构造森林全是根</strong>（把给出的权值全部当做根结点）</p>
<p>2、<strong>选用两小造新树</strong>（选出两个权值最小的，一个做左子树，一个为右子树，双亲结点的权值为它们权值之和，构造这样的二叉树）</p>
<p>3、<strong>删除两小添新人</strong>（把刚才的两个最小的结点删除，把它俩的双亲结点添加）</p>
<p>4、<strong>重复2、3剩单根</strong></p>
<p>因此哈夫曼树的结点2的度为0或2，没有度为1的结点</p>
<p>包含n个叶子结点的哈夫曼树中共有2n-1个结点（包含n棵树的森林要经过n-1次合并才能形成哈夫曼树，共产生n-1个新节点）</p>
<h3 id="哈夫曼树的存储结构"><a href="#哈夫曼树的存储结构" class="headerlink" title="哈夫曼树的存储结构"></a>哈夫曼树的存储结构</h3><p><img src="https://hakaimg.com/i/2022/11/29/fn8yr8.png"></p>
<h3 id="构造哈夫曼树算法的实现"><a href="#构造哈夫曼树算法的实现" class="headerlink" title="构造哈夫曼树算法的实现"></a>构造哈夫曼树算法的实现</h3><p><img src="https://hakaimg.com/i/2022/11/29/fpvki7.png"></p>
<p><img src="https://hakaimg.com/i/2022/11/29/fq8dyw.png"></p>
<h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><p>在哈夫曼树中约定左分支标记为 0, 右分支标记为 1,则根结点到每个叶子结点路径上的 0、 1序列即为相应字符的编码。</p>
<p><strong>前缀编码</strong>：如果在一个编码方案中，任一个编码都不是其他任何编码的前缀（最左子串）， 则称编码是前缀编码</p>
<p><strong>哈夫曼编码</strong>：对一棵具有n个叶子的哈夫曼树，若对树中的每个左分支 赋予0, 右分支 赋予1’则从根到每个叶子的路径上，各分支 的赋值分别构成一个二进制串， 该二进制串就称为 哈夫曼编码</p>
<p><strong>性质</strong></p>
<p><strong>1、哈夫曼编码是前缀编码</strong></p>
<p>没有一片树叶是另一片树叶的祖先，所以每个叶结点的编码就不可能是其他叶结点编码的前缀</p>
<p>每个字符都为叶子结点</p>
<p><strong>2、哈夫曼编码是最优前缀编码</strong></p>
<p>哈夫曼树带权路径长度最短，故字符编码的总长最短</p>
<h3 id="哈夫曼编码的算法"><a href="#哈夫曼编码的算法" class="headerlink" title="哈夫曼编码的算法"></a>哈夫曼编码的算法</h3><p>依次以叶子为出发点，向上回溯至根结 点为止。 回溯时走左分支则生成代码 0, 走右分支则生成代码l</p>
<p><img src="https://hakaimg.com/i/2022/11/29/gtibb2.png"></p>
<h1 id="五、图"><a href="#五、图" class="headerlink" title="五、图"></a>五、图</h1><h2 id="图的基本概念和术语"><a href="#图的基本概念和术语" class="headerlink" title="图的基本概念和术语"></a>图的基本概念和术语</h2><p>图(Graph) G由两个集合V和E组成，记为G&#x3D;(V,E）</p>
<p>V是顶点的有穷<strong>非空</strong>集合</p>
<p>E是V中顶点偶对的有穷集合</p>
<p><strong>图可以只有顶点没有边</strong></p>
<p><strong>有向图</strong>中，顶点对&lt;x,y&gt;是有序的，它称为从顶点 x到顶点 y的一条有向边，x是有向边的始点，y是有向边的终点。或 x为弧尾， y为弧头。</p>
<p><strong>无向图</strong>中，顶点对 ( x, y)是无序的，它称为顶点x与顶点y相关联的一条边。</p>
<p><strong>完全图</strong>：任意两个点都有一条边相连，若有n个顶点就有n(n-1)&#x2F;2条边，则为无向完全图；若有n(n-1)条弧，则称有向完全图。</p>
<p><strong>稀疏图和稠密图</strong>：有很少条边或弧（如 e&lt;nlogn)的图称为稀疏图， 反之称为稠密图</p>
<p><strong>权和网</strong>：在实际应用中，每条边可以标上具有某种含义的数值，该数值称为该边上的权。带权的图通常称为网。</p>
<p> <strong>度、入度和出度</strong>：顶知的度是指和v相关联的边的数目，记为 TD(v);入度是以顶点v为头的弧的数目，记 为ID(v); 出度是以顶点 v 为尾的弧的数目，记为OD(v);顶点 v 的度为 TD(v) &#x3D; ID(v) + OD(v)。</p>
<p><strong>当有向图中仅有一个顶点的入度为0，其余顶点的入度均为1，此时是一棵有向树</strong></p>
<p><strong>路径</strong>：接续的边构成的顶点序列。</p>
<p><strong>路径长度</strong>：路径上边或弧的数目&#x2F;权值之和</p>
<p><strong>回路（环</strong>）：第一个顶点和最后一个顶点相同的路径。</p>
<p><strong>简单路径</strong>：除路径起点和终点相同外，其余顶点均不相同的路径</p>
<p><strong>简单回路（简单环）</strong>：除路径起点和终点相同外，其余顶点均不相同的路径</p>
<p><img src="https://hakaimg.com/i/2022/11/29/i75mp5.png"></p>
<p><strong>连通图（强连通图）</strong>：果对千图中任意两个顶点 V1， V,2 E V, V;1和 V2 都是连通的，则称 G 是连通图。</p>
<p><strong>连通分量</strong>： 指的是无向图中的极大连通子图。</p>
<p><strong>生成</strong>树：包含无向图G所有顶点的极小连通子图</p>
<p><strong>生成森林</strong>：对非连通图，由各个连通分量的生成树的集合</p>
<h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><h3 id="数组（邻接矩阵）表示法"><a href="#数组（邻接矩阵）表示法" class="headerlink" title="数组（邻接矩阵）表示法"></a>数组（邻接矩阵）表示法</h3><p><strong>无向图的邻接矩阵表示法</strong></p>
<p><img src="https://hakaimg.com/i/2022/11/29/il98pn.png"></p>
<p><strong>有向图的邻接矩阵表示法</strong></p>
<p><img src="https://hakaimg.com/i/2022/11/29/in9jfe.png"></p>
<p><strong>网的邻接矩阵表示法</strong></p>
<p><img src="https://hakaimg.com/i/2022/11/29/io6fk7.png"></p>
<h4 id="邻接矩阵的建立"><a href="#邻接矩阵的建立" class="headerlink" title="邻接矩阵的建立"></a>邻接矩阵的建立</h4><p><strong>存储结构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//-----图的邻接矩阵存储表示－－－－－</span><br><span class="line">#define Maxint 32767／／表示极大值， 即 OO</span><br><span class="line">#define MVNum 100 ／／最大顶点数</span><br><span class="line">typedef char VerTexType;／／假设顶点的数据类型为字符型</span><br><span class="line">typedef int ArcType;／／假设边的权值类型为整型</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123; </span><br><span class="line">VerTexType vexs [MVNum] ; ／／顶点表</span><br><span class="line">ArcType arcs[MVNum] [MVNum]; ／／邻接矩阵</span><br><span class="line">int vexnum,arcnum; ／／图的当前点数和边数</span><br><span class="line">&#125; AMGraph; </span><br></pre></td></tr></table></figure>

<p><img src="https://hakaimg.com/i/2022/11/29/lsdx9r.png"></p>
<p><img src="https://hakaimg.com/i/2022/11/29/lszzyh.png"></p>
<h4 id="邻接矩阵的优缺点"><a href="#邻接矩阵的优缺点" class="headerlink" title="邻接矩阵的优缺点"></a>邻接矩阵的优缺点</h4><p><strong>优点：</strong></p>
<p>便于判断两个顶点之间是否有边， 即根据A[i] [j] &#x3D; 0或1来判断</p>
<p>便于计算各个顶点的度。</p>
<p><strong>缺点：</strong></p>
<p>不便于增加和删除顶点、</p>
<p>不便于统计边的数目，需要扫描邻接矩阵所有元素才能统计完毕，时间复杂度为O(n^2）;</p>
<p>邻接矩阵表示法的空间复杂度为O(n*n)、</p>
<p>不适合存储稀疏图</p>
<h3 id="邻接表表示法"><a href="#邻接表表示法" class="headerlink" title="邻接表表示法"></a>邻接表表示法</h3><p><img src="https://hakaimg.com/i/2022/11/29/m1dwgm.png"></p>
<p><img src="https://hakaimg.com/i/2022/11/29/ngwhwv.png"></p>
<p><strong>无向图</strong></p>
<p>特点：邻接表不唯一、若有n个结点，e条边，则其邻接表需要n个头结点和2e个表结点，适宜存储稀疏图。存储空间为O(n+2e)、顶点Vi的度为第i个单链表中的结点数</p>
<p><img src="https://hakaimg.com/i/2022/11/29/m32ewr.png"></p>
<p><strong>有向图</strong></p>
<p><img src="https://hakaimg.com/i/2022/11/29/m8hk4t.png"></p>
<h4 id="邻接表的建立"><a href="#邻接表的建立" class="headerlink" title="邻接表的建立"></a>邻接表的建立</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//- - - - -图的邻接表存储表示－ －－－－</span><br><span class="line">#define MVNum 100／／最大顶点数</span><br><span class="line"></span><br><span class="line">typedef struct ArcNode／／边结点</span><br><span class="line">&#123;</span><br><span class="line">int adjvex; 			//该边所指向的顶点的位置</span><br><span class="line">struct ArcNode * nextarc; ／／指向下一条边的指针</span><br><span class="line">Otherinfo info; ／／和边相关的信息</span><br><span class="line">&#125;ArcNode; </span><br><span class="line"></span><br><span class="line">typedef struct VNode ／／顶点信息</span><br><span class="line">&#123;</span><br><span class="line">VerTexType data; </span><br><span class="line">ArcNode *firstarc; ／／指向第一条依附该顶点的边的指针</span><br><span class="line">&#125; VNode,AdjList[MVNum]; //AdjList表示邻接表类型</span><br><span class="line"></span><br><span class="line">typedef struct 		／／邻接表</span><br><span class="line">&#123;</span><br><span class="line">AdjList vertices; 	</span><br><span class="line">int vexnum,arcnum; ／／图的当前顶点数和边数</span><br><span class="line">&#125;ALGraph; </span><br></pre></td></tr></table></figure>

<p><img src="https://hakaimg.com/i/2022/11/29/mh7ost.png"></p>
<p><img src="https://hakaimg.com/i/2022/11/29/n6ws49.png"></p>
<h4 id="邻接表的优缺点"><a href="#邻接表的优缺点" class="headerlink" title="邻接表的优缺点"></a>邻接表的优缺点</h4><p><strong>优点：</strong></p>
<p>便于增加和删除顶点。</p>
<p>便千统计边的数目， 按顶点表顺序扫描所有边表可得到边的数目，时间复杂度为 O(n + e) 。</p>
<p>空间效率高。邻接表或逆邻接表表示的空间复杂度为 O(n + e)</p>
<p>适合表示稀疏图</p>
<p><strong>缺点：</strong></p>
<p>不便于判断顶点之间是否有边，最坏情况下要耗费 O(n)时间。</p>
<p>不便于计算有向图各个顶点的度</p>
<h3 id="邻接矩阵与邻接表的关系"><a href="#邻接矩阵与邻接表的关系" class="headerlink" title="邻接矩阵与邻接表的关系"></a>邻接矩阵与邻接表的关系</h3><p><strong>联系：</strong></p>
<p>邻接表中每个链表对应于邻接矩阵中的一行，链表中结点个数等于一行中非零元素的个数</p>
<p><strong>区别：</strong></p>
<p>对于任一确定的无向图，邻接矩阵是唯一的（行列号与顶点编号一致），但邻接表不唯一（链表次序与顶点编号无关）</p>
<p>邻接矩阵的空间复杂度为O(n^2),而邻接表的空间复杂度为O(n+e)</p>
<p><strong>用途：</strong></p>
<p>邻接矩阵多用于稠密图</p>
<p>邻接表多用于稀疏图</p>
<h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h3><p>是<strong>有向图</strong>的另一种链式存储结构</p>
<p><strong>弧结点</strong>：</p>
<p>尾域 (tailvex) 和头域 (headvex) 分别指示弧尾和弧头这两个顶点在 图中的位置</p>
<p>链域hlink 指向弧头相同的下一条弧，而链域 tlink 指向弧尾相同的下一条弧</p>
<p>info域指 向该弧的相关信息。</p>
<p><strong>头结点</strong>：</p>
<p>firstin 和 firstout 为两个链域，分别指向以该顶点为弧头或弧尾的第一个弧结点。</p>
<p><img src="https://hakaimg.com/i/2022/11/29/nlvhgt.png"></p>
<h3 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h3><p>是<strong>无向图</strong>的另一种链式存储结构</p>
<p><strong>边结点</strong>：</p>
<p>mark 为标志域，可用以标记该条边是否被搜索过； </p>
<p> ivex 和 jvex 为该边依附的两个顶点在表头数组中的位置；</p>
<p>ilink 指向下一条依附于顶点 ivex 的边</p>
<p> jlink 指向下一条依附于顶点jvex的边</p>
<p>info为指向和边相关的各种信息的指针域</p>
<p><strong>顶点结点</strong>：</p>
<p>data域存储和 该顶点相关的信息</p>
<p>firstedge域指示第一条依附于该顶点的边</p>
<p><img src="https://hakaimg.com/i/2022/11/29/nqio79.png"></p>
<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><p><strong>避免重复访问</strong></p>
<p>设置辅助数组 visited[n]，用来标记每个被访问过的顶点；初始状态 visited[i]&#x3D;0，被访问后修改visited[i]&#x3D;1，防止被多次访问</p>
<p>无论是DFS还是BFS，空间复杂度都相同，为O(n)</p>
<h3 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a>深度优先搜索（DFS）</h3><p>1、从某个顶点出发，访问该顶点</p>
<p>2、访问该顶点的第一个没有被访问的邻接点，访问该顶点；以该顶点为新的顶点，重复此步骤，直到刚访问过的顶点没有未被访问的邻接点为止。</p>
<p>3、返回前一个访问过的且仍有未被访问的邻接点的顶点，找出该顶点的下一个未被访问的 邻接点， 访问该顶点</p>
<p>4、重复步骤 (2) 和(3), 直至图中所有顶点都被访问过，搜索结束</p>
<p><img src="https://hakaimg.com/i/2022/11/29/x8uq6u.png"></p>
<p><img src="https://hakaimg.com/i/2022/11/29/x91lqq.png"></p>
<p>v1-&gt;v2-&gt;v-&gt;v4-&gt;v8-&gt;v5-&gt;v3-&gt;v6-&gt;v7</p>
<h4 id="邻接矩阵表示的无向图的深度遍历"><a href="#邻接矩阵表示的无向图的深度遍历" class="headerlink" title="邻接矩阵表示的无向图的深度遍历"></a>邻接矩阵表示的无向图的深度遍历</h4><p>时间复杂度为O(n*n),</p>
<p>稠密图适合在邻接矩阵上进行深度遍历</p>
<p><img src="https://hakaimg.com/i/2022/11/29/xebcwg.png"></p>
<h4 id="邻接表上的深度遍历"><a href="#邻接表上的深度遍历" class="headerlink" title="邻接表上的深度遍历"></a>邻接表上的深度遍历</h4><p>时间复杂度为O(n+e)</p>
<p>稀疏图适合在邻接表上进行深度遍历</p>
<h3 id="广度优先搜索（BFS）"><a href="#广度优先搜索（BFS）" class="headerlink" title="广度优先搜索（BFS）"></a>广度优先搜索（BFS）</h3><p>从图的某个结点出发，首先依次访问该结点的所有邻接顶点，在按照这些顶点被访问的先后依次访问与它们相邻接的所有未被访问的顶点，重复此过程，直至所有顶点均被访问为止</p>
<p>使用邻接矩阵存储时，时间复杂度为O(n*n)</p>
<p>使用邻接表存储时，时间复杂度为O(n+e)</p>
<p><img src="https://hakaimg.com/i/2022/11/29/xnuaq7.png"></p>
<p><img src="https://hakaimg.com/i/2022/11/29/xoilu6.png"></p>
<p>依次检查u的所有邻接点w, FirstAdjVex(G,u)表示u的第一个邻接点 </p>
<p>NextAdjVex(G,u,w)表示u相对于w的下一个邻接点，w&gt;&#x3D;0表示存在邻接点</p>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p> 在一个连通网的所有生成树中，各边的权值之和最小的那棵生成树称 为该连通网的最小代价生成树,简称为最小生成树。</p>
<p>生成树：所有顶点均连接在一起，但不存在回路的图</p>
<h3 id="MST性质"><a href="#MST性质" class="headerlink" title="MST性质"></a>MST性质</h3><p><img src="https://hakaimg.com/i/2022/11/29/yrnd52.png"></p>
<h3 id="普里姆-Prim-算法"><a href="#普里姆-Prim-算法" class="headerlink" title="普里姆 (Prim) 算法"></a>普里姆 (Prim) 算法</h3><p>选择点</p>
<p>每次选择最小边时， 可能存在多条同样权值的边可选， 此时任选其一即可</p>
<p>时间复杂度为O(n*n)</p>
<p>适应于稠密图</p>
<p><img src="https://hakaimg.com/i/2022/11/29/1270doq.png"></p>
<p><img src="https://hakaimg.com/i/2022/11/29/127n7gg.png"></p>
<h3 id="克鲁斯卡尔-Kruskal-算法"><a href="#克鲁斯卡尔-Kruskal-算法" class="headerlink" title="克鲁斯卡尔 (Kruskal) 算法"></a>克鲁斯卡尔 (Kruskal) 算法</h3><p>选择边</p>
<p>切记不能有环，最小生成树可能不唯一</p>
<p>时间复杂度为O(eloge) e为边数</p>
<p>适应于稀疏图</p>
<p><img src="https://hakaimg.com/i/2022/11/29/12989cy.png"></p>
<p><img src="https://hakaimg.com/i/2022/11/29/129qy55.png"></p>
<p><img src="https://hakaimg.com/i/2022/11/29/129wt1j.png"></p>
<h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><p>在带权有向网中，习惯上称 路径上的第一个顶点为源点(Source), 最后一个顶点为终点(Destination)。</p>
<p>从源点到终点的多条路径中，寻找一条各边权值之和最小的路径，即最短路径，路径上不一定要包含n个顶点，也不一定包含n-1条边</p>
<h3 id="某源点到其他各点的最短路径"><a href="#某源点到其他各点的最短路径" class="headerlink" title="某源点到其他各点的最短路径"></a>某源点到其他各点的最短路径</h3><h4 id="Dijkstra（迪杰斯特拉）算法"><a href="#Dijkstra（迪杰斯特拉）算法" class="headerlink" title="Dijkstra（迪杰斯特拉）算法"></a>Dijkstra（迪杰斯特拉）算法</h4><p><img src="https://hakaimg.com/i/2022/11/29/12nmwif.png"></p>
<p><img src="https://hakaimg.com/i/2022/11/29/12os86k.png"></p>
<p><img src="https://hakaimg.com/i/2022/11/29/12p6quu.png"></p>
<h3 id="任意一对两点之间最短路径"><a href="#任意一对两点之间最短路径" class="headerlink" title="任意一对两点之间最短路径"></a>任意一对两点之间最短路径</h3><p>每次以一个顶点为源点，重复执行Dijkstra算法n次</p>
<h4 id="Floyd（弗洛伊德）算法"><a href="#Floyd（弗洛伊德）算法" class="headerlink" title="Floyd（弗洛伊德）算法"></a>Floyd（弗洛伊德）算法</h4><p><img src="https://hakaimg.com/i/2022/11/29/12sh18p.png"></p>
<p><img src="https://hakaimg.com/i/2022/11/29/12swta2.png"></p>
<p><img src="https://hakaimg.com/i/2022/11/29/12t1kvd.png"></p>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p><strong>有向无环图</strong>：无环的有向图，简称GAG图</p>
<p>AOV网：用一个有向图表示一个工程的各子工程及其相互制约的关系。以<strong>顶点表示活动</strong>，<strong>弧表示</strong>活动之间的优先制约关系，称这种有向图为顶点表示活动的网</p>
<p><img src="https://hakaimg.com/i/2022/11/30/ttkfpf.png"></p>
<p><img src="https://hakaimg.com/i/2022/11/30/tw1qma.png"></p>
<p>拓扑排序的应用：</p>
<p>检测AOV网中是否存在环；对有向图构造其顶点的拓扑有序序列，若网中所有顶点都在它的拓扑有序序列中，则该AOV网必定不存在环。</p>
<h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><p>AOE网：以弧表示活动，以顶点表示活动的开始或结束事件，弧的权表示活动持续时间，称这种有向图为边表示活动的网。</p>
<p>关键路径———–&gt;路径长度最长的路径</p>
<p>路径长度———–&gt;路径上各活动持续时间之和</p>
<p><img src="https://hakaimg.com/i/2022/11/30/u3sbwj.png"></p>
<p><img src="https://hakaimg.com/i/2022/11/30/u5nllr.png"></p>
<p><strong>ve（j）是最大值    vl（j）是最小值</strong></p>
<p><img src="https://hakaimg.com/i/2022/11/30/vn6xz6.png"></p>
<p><img src="https://hakaimg.com/i/2022/11/30/vr4ujo.png"></p>
<p>关键活动就是a1-&gt;a4-&gt;a7-&gt;a8-&gt;a10-&gt;a11</p>
<h1 id="六、查找"><a href="#六、查找" class="headerlink" title="六、查找"></a>六、查找</h1><h2 id="线性表的查找"><a href="#线性表的查找" class="headerlink" title="线性表的查找"></a>线性表的查找</h2><h3 id="顺序查找法"><a href="#顺序查找法" class="headerlink" title="顺序查找法"></a>顺序查找法</h3><p><strong>时间复杂度O(n),空间复杂度O(1)</strong></p>
<p><strong>平均查找长度为（n+1）&#x2F;2</strong></p>
<p>从最后一个元素开始比较，把所要查找的元素赋值给顺序表中的零号位置，则0号位置起到了哨兵作用，，只需要从后往前查找，每一次循环只需要进行一次比较</p>
<p><img src="https://hakaimg.com/i/2022/12/01/h4xxk9.png"></p>
<p>比较次数与key的位置有关：查找第i个元素，需要比较n-i+1次，查找失败，需要比较n+1次</p>
<p><img src="https://hakaimg.com/i/2022/12/01/h816s5.png"></p>
<p><strong>顺序查找的特点：</strong></p>
<p>算法简单、逻辑次序无要求，适用于不同的存储结构</p>
<p>缺点：平均查找长度较大，查找效率低，当n很大时，不宜采用</p>
<h3 id="折半查找法"><a href="#折半查找法" class="headerlink" title="折半查找法"></a>折半查找法</h3><p><strong>时间复杂度为O(longn)</strong></p>
<p><strong>线性表必须采用顺序存储结构，并且表中元素有序排列，基本都是递增有序排列</strong></p>
<p>用low和high来表示当前查找区间的下界和 上界，mid为区间的中间位置</p>
<p><img src="https://hakaimg.com/i/2022/12/01/i7pr1d.png"></p>
<p><img src="https://hakaimg.com/i/2022/12/01/hddbej.png"></p>
<p><strong>算法分析</strong></p>
<p><img src="https://hakaimg.com/i/2022/12/01/hgeylw.png"></p>
<p><strong>优点：</strong></p>
<p>效率比顺序查找高</p>
<p><strong>缺点：</strong></p>
<p>只适用于有序表，且仅限于顺序存储结构（对线性链表无效）</p>
<h3 id="分块查找法"><a href="#分块查找法" class="headerlink" title="分块查找法"></a>分块查找法</h3><p>每一块里面的元素排列可以是有序的，也可以是无序的</p>
<p><img src="https://hakaimg.com/i/2022/12/01/ia2ekj.png"></p>
<p><img src="https://hakaimg.com/i/2022/12/01/ibqip5.png"></p>
<p>优点：</p>
<p>插入删除比较容易，无需进行大量移动</p>
<p>缺点：</p>
<p>要增加一个索引表的存储空间并对初始索引表进行排序运算</p>
<p>如果线性表既要快速查找又要经常动态变化，则可以使用分块查找</p>
<h3 id="三种顺序查找的比较"><a href="#三种顺序查找的比较" class="headerlink" title="三种顺序查找的比较"></a>三种顺序查找的比较</h3><p><img src="https://hakaimg.com/i/2022/12/01/idkfcl.png"></p>
<h2 id="树表的查找"><a href="#树表的查找" class="headerlink" title="树表的查找"></a>树表的查找</h2><h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><p>二叉排序树或者是一棵空树，或者是具有下列性质的二叉树： </p>
<p>(I) 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； </p>
<p>(2) 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； </p>
<p>(3) 它的左、 右子树也分别为二叉排序树。</p>
<p>二叉排序树是递归定义的。 由定义可以得出二叉排序树的一个重要性质：<strong>中序遍历</strong>一棵二叉 树时可以得到一个结点值<strong>递增的有序序列。</strong></p>
<h4 id="二叉排序树的查找"><a href="#二叉排序树的查找" class="headerlink" title="二叉排序树的查找"></a>二叉排序树的查找</h4><p><img src="https://hakaimg.com/i/2022/12/01/ik5gvx.png"></p>
<p><strong>分析</strong></p>
<p><img src="https://hakaimg.com/i/2022/12/01/ilwgab.png"></p>
<h4 id="二叉排序树的插入和生成"><a href="#二叉排序树的插入和生成" class="headerlink" title="二叉排序树的插入和生成"></a>二叉排序树的插入和生成</h4><p>生成：</p>
<p><img src="https://hakaimg.com/i/2022/12/01/s525e6.png"></p>
<p>插入：</p>
<p>不同插入次序的序列生成不同形态的二叉排序树</p>
<h4 id="二叉排序树的删除"><a href="#二叉排序树的删除" class="headerlink" title="二叉排序树的删除"></a>二叉排序树的删除</h4><p><img src="https://hakaimg.com/i/2022/12/01/s8lzqw.png"></p>
<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p><img src="https://hakaimg.com/i/2022/12/01/s9rk0r.png"></p>
<p><strong>平衡因子&#x3D;结点左子树的高度-结点右子树的高度，平衡因子只能是 -1、0、1</strong></p>
<p>平衡二叉树的高度保持在O(logn)</p>
<p><img src="https://hakaimg.com/i/2022/12/01/sdcdb5.png"></p>
<p><img src="https://hakaimg.com/i/2022/12/01/se9yih.png"></p>
<p>LL型：</p>
<p><img src="https://hakaimg.com/i/2022/12/01/shy9yu.png"></p>
<p>RR型：</p>
<p><img src="https://hakaimg.com/i/2022/12/01/shjqua.png"></p>
<p>LR型：</p>
<p><img src="https://hakaimg.com/i/2022/12/01/sinaju.png"></p>
<p><strong>RR型与LR型类似</strong></p>
<h2 id="散列表的查找"><a href="#散列表的查找" class="headerlink" title="散列表的查找"></a>散列表的查找</h2><p><img src="https://hakaimg.com/i/2022/12/01/sopdbk.png"></p>
<p><img src="https://hakaimg.com/i/2022/12/01/tuoysd.png"></p>
<p><img src="https://hakaimg.com/i/2022/12/01/tuwen4.png"></p>
<p><img src="https://hakaimg.com/i/2022/12/01/tvcok1.png"></p>
<h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><p>选取该函数，依该函数按关键字计算元素的存储位置，并按此存放</p>
<p>(1)函数计算要简单，每一关键字只能有一个散列地址与之对应； </p>
<p>(2) 函数的值域需在表长的范围内， 计算出的散列地址的分布应均匀，尽可能减少冲突。</p>
<h4 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h4><p><img src="https://hakaimg.com/i/2022/12/01/st8h42.png"></p>
<h4 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h4><p><img src="https://hakaimg.com/i/2022/12/01/suck94.png"></p>
<h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><p><img src="https://hakaimg.com/i/2022/12/01/sqvqtr.png"></p>
<p><strong>解决冲突</strong></p>
<p><img src="https://hakaimg.com/i/2022/12/01/syrjt8.png"></p>
<h4 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h4><p>有冲突时就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将数据元素存入</p>
<h5 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h5><p><img src="https://hakaimg.com/i/2022/12/01/syk11h.png"></p>
<p><img src="https://hakaimg.com/i/2022/12/01/sy057n.png"></p>
<h5 id="二次探测法"><a href="#二次探测法" class="headerlink" title="二次探测法"></a>二次探测法</h5><p><img src="https://hakaimg.com/i/2022/12/01/t0au6k.png"></p>
<h5 id="伪随机探测法"><a href="#伪随机探测法" class="headerlink" title="伪随机探测法"></a>伪随机探测法</h5><p><img src="https://hakaimg.com/i/2022/12/01/t11mp0.png"></p>
<h4 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h4><p>优点：</p>
<p>非同义词不会冲突，无“聚集”现象、链表上结点空间动态申请，更适合于表长不确定的情况</p>
<p><img src="https://hakaimg.com/i/2022/12/01/t3lujj.png"></p>
<p><img src="https://hakaimg.com/i/2022/12/01/tryg86.png"></p>
<h1 id="七、排序"><a href="#七、排序" class="headerlink" title="七、排序"></a>七、排序</h1><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>每一趟将一个待排序的记录，按其关键字的大小插入到已经排好序 的一组记录的适当位置上，直到所有待排序记录全部插入为止。</p>
<h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p>采用<strong>顺序查找法</strong>查找插入位置</p>
<p>从第i个元素无序</p>
<p><img src="https://hakaimg.com/i/2022/12/01/u5kg7c.png"></p>
<p><img src="https://hakaimg.com/i/2022/12/01/u62bfv.png"></p>
<h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><p>查找插入位置时采用折半查找法</p>
<p>减少了比较次数，但是没有减少移动次数</p>
<p>时间复杂度为O(n*n),空间复杂度为O(1)</p>
<p><img src="https://hakaimg.com/i/2022/12/01/u93f38.png"></p>
<p><img src="https://hakaimg.com/i/2022/12/01/uaadb8.png"></p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>先将整个待排序记录序列<strong>分割成几组</strong>，对每组分别进行<strong>直接插入排序</strong>， 这样当经过几次分组排序后，整个序列中的记录 “<strong>基本有序</strong>” 时，再对全体记录进行一次直接插入排序</p>
<p>一次移动，移动位置较大，跳跃式地接近排序后的最终位置</p>
<p>最后一次只需要少量移动</p>
<p>增量序列必须是递减的，最后一个必须是1</p>
<p>增量序列应该是互质的</p>
<p><img src="https://hakaimg.com/i/2022/12/01/uih3vj.png"></p>
<p><img src="https://hakaimg.com/i/2022/12/01/udfu72.png"></p>
<p><img src="https://hakaimg.com/i/2022/12/01/8gbud7y.png"></p>
<p><img src="https://hakaimg.com/i/2022/12/01/ugs23h.png"></p>
<h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><p>两两比较待排序记录的关键字，一旦发现两个记录不满足次序要求 时则进行交换，直到整个序列全部满足要求为止</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>两两比较相邻记录的关键字， 如果发生逆序，则进行交换，从而使关键字小的记录如气泡一般逐渐往上 ＂漂浮＂ （左移），或者使关键字大的记录如石块一样逐渐向下 ＂坠落” （右移）。</p>
<p>一共有n个元素，则需要比较n-1趟，第m趟，每一趟需要比较n-m次</p>
<p><img src="https://hakaimg.com/i/2022/12/01/unumhc.png"></p>
<p><img src="https://hakaimg.com/i/2022/12/01/uoih9d.png"></p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><strong>快速排序不适宜对原本有序或者基本有序的记录序列进行排序</strong></p>
<p><img src="https://hakaimg.com/i/2022/12/01/vru2kj.png"></p>
<p><img src="https://hakaimg.com/i/2022/12/01/vpyje0.png"></p>
<p><img src="https://hakaimg.com/i/2022/12/01/8tdj8fe.png"></p>
<p><img src="https://hakaimg.com/i/2022/12/01/upt77y.png"></p>
<p><img src="https://hakaimg.com/i/2022/12/01/ur05mq.png"></p>
<p><img src="https://hakaimg.com/i/2022/12/01/vkqmwc.png"></p>
<p><img src="https://hakaimg.com/i/2022/12/01/vkwx0v.png"></p>
<p><img src="https://hakaimg.com/i/2022/12/01/vlaacs.png"></p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><p>在待排序的数据中选出最大（小）的元素放在其最终的位置</p>
<p><img src="https://hakaimg.com/i/2022/12/01/vv10z1.png"></p>
<p><img src="https://hakaimg.com/i/2022/12/01/vvkg9j.png"></p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p><img src="https://hakaimg.com/i/2022/12/01/w0ugrv.png"></p>
<p><img src="https://hakaimg.com/i/2022/12/01/vx8yt2.png"></p>
<p><strong>第i个元素，它的左孩子就是2i，右孩子就是2i+1</strong></p>
<p><img src="https://hakaimg.com/i/2022/12/01/vz2ksq.png"></p>
<h4 id="堆调整"><a href="#堆调整" class="headerlink" title="堆调整"></a>堆调整</h4><p><img src="https://hakaimg.com/i/2022/12/01/w2nwuk.png"></p>
<p><img src="https://hakaimg.com/i/2022/12/01/w3uo9j.png"></p>
<h4 id="堆的建立"><a href="#堆的建立" class="headerlink" title="堆的建立"></a>堆的建立</h4><p><img src="https://hakaimg.com/i/2022/12/01/w82yv3.png"></p>
<h4 id="堆排序算法"><a href="#堆排序算法" class="headerlink" title="堆排序算法"></a>堆排序算法</h4><p>时间复杂度为O(nlogn)</p>
<p>空间复杂度为O(1)</p>
<p><img src="https://hakaimg.com/i/2022/12/01/w97ct6.png"></p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>将两个或两个以上的有序表合并成一个有序表的过程。将两个 有序表合并成一个有序表的过程称为2-路归并</p>
<p><img src="https://hakaimg.com/i/2022/12/01/wbkkho.png"></p>
<p><img src="https://hakaimg.com/i/2022/12/01/wctq0f.png"></p>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p><img src="https://hakaimg.com/i/2022/12/01/wenb58.png"></p>
<p><img src="https://hakaimg.com/i/2022/12/01/x49cuw.png"></p>
<h2 id="排序的对比"><a href="#排序的对比" class="headerlink" title="排序的对比"></a>排序的对比</h2><p><img src="https://hakaimg.com/i/2022/12/01/x5tdnz.png"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">衿</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/post/79666db.html">http://example.com/post/79666db.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">衿</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://hakaimg.com/i/2022/10/05/nwneti.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/201b3bcb.html"><img class="prev-cover" src="https://hakaimg.com/i/2022/10/05/nwneti.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">maven工程</div></div></a></div><div class="next-post pull-right"><a href="/post/e5918a.html"><img class="next-cover" src="https://hakaimg.com/i/2022/10/05/nwneti.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">SpringMvc</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/tx.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">衿</div><div class="author-info__description">心里有李</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://www.bilibili.com/"><i class="iconfont icon-youxishoubing"></i><span>摸鱼</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><b><font color="#e66b6d">双</font> <font color="#e66d98">手</font> <font color="#e66cc6">合</font> <font color="#cc6de6">十</font> <font color="#9770e6">成</font> <font color="#6d93e6">为</font> <font color="#6fcde6">自</font> <font color="#72e6b6">己</font> <font color="#72e689">的</font> <font color="#99e670">神</font>, <font color="#cde670">自</font> <font color="#e6df72">己</font> <font color="#e6c073">所</font> <font color="#e6a271">信</font> <font color="#e6796f">念</font> <font color="#e65454">的</font> <font color="#e63333">即</font> <font color="#e62c2c">是</font> <font color="#e60101">信</font> <font color="#e60101">仰</font></b> <p align="center"><img src="https://img-blog.csdnimg.cn/f7384c88956d4378b72e47548e19c9f8.gif" width="50" alt="mao"></p> <p align="center">微信号：lzj17634506638</p> <p align="center">QQ号：1953494249</p></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">1.</span> <span class="toc-text">一、线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text">线性表的类型定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="toc-number">1.2.</span> <span class="toc-text">顺序表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.1.</span> <span class="toc-text">顺序表的基本操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E8%A1%A8"><span class="toc-number">1.3.</span> <span class="toc-text">链式表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.1.</span> <span class="toc-text">单链表的基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">循环链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">1.3.3.</span> <span class="toc-text">双向链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.4.</span> <span class="toc-text">顺序表与链表的比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%90%88%E5%B9%B6"><span class="toc-number">1.5.</span> <span class="toc-text">线性表的合并</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%90%88%E5%B9%B6"><span class="toc-number">1.6.</span> <span class="toc-text">有序表的合并</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">2.</span> <span class="toc-text">二、栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">2.1.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-number">2.1.1.</span> <span class="toc-text">栈的定义和特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%A0%88"><span class="toc-number">2.1.2.</span> <span class="toc-text">顺序栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%A0%88"><span class="toc-number">2.1.3.</span> <span class="toc-text">链栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E9%80%92%E5%BD%92"><span class="toc-number">2.1.4.</span> <span class="toc-text">栈和递归</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">2.2.</span> <span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-number">2.2.1.</span> <span class="toc-text">队列的定义和特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97"><span class="toc-number">2.2.2.</span> <span class="toc-text">顺序队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E9%98%9F%E5%88%97"><span class="toc-number">2.2.3.</span> <span class="toc-text">链队列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">三、串、数组和广义表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2"><span class="toc-number">3.1.</span> <span class="toc-text">串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E3%80%81%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.1.</span> <span class="toc-text">串的类型定义、存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94BF%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.2.</span> <span class="toc-text">串的算法——BF算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94KMP%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.3.</span> <span class="toc-text">串的算法——KMP算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">3.2.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E7%89%B9%E7%82%B9"><span class="toc-number">3.2.1.</span> <span class="toc-text">数组的定义及特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">3.2.2.</span> <span class="toc-text">数组的顺序存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8%EF%BC%88%E5%AF%B9%E7%A7%B0%E3%80%81%E4%B8%89%E8%A7%92%E3%80%81%E5%AF%B9%E8%A7%92%E3%80%81%E7%A8%80%E7%96%8F%EF%BC%89"><span class="toc-number">3.2.3.</span> <span class="toc-text">特殊矩阵压缩存储（对称、三角、对角、稀疏）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="toc-number">3.3.</span> <span class="toc-text">广义表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E4%B9%89%E8%A1%A8%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">3.3.1.</span> <span class="toc-text">广义表的性质</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">4.</span> <span class="toc-text">四、树和二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="toc-number">4.1.</span> <span class="toc-text">树的定义与基本术语</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">4.2.</span> <span class="toc-text">二叉树的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">4.3.</span> <span class="toc-text">二叉树的性质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">4.4.</span> <span class="toc-text">二叉树的存储结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">4.5.</span> <span class="toc-text">遍历二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="toc-number">4.5.1.</span> <span class="toc-text">先序遍历算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="toc-number">4.5.2.</span> <span class="toc-text">中序遍历算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="toc-number">4.5.3.</span> <span class="toc-text">后序遍历算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="toc-number">4.5.4.</span> <span class="toc-text">层次遍历算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">4.6.</span> <span class="toc-text">遍历算法的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="toc-number">4.6.1.</span> <span class="toc-text">二叉树的建立</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">4.6.2.</span> <span class="toc-text">复制二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="toc-number">4.6.3.</span> <span class="toc-text">计算二叉树的深度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%93%E7%82%B9%E6%80%BB%E6%95%B0"><span class="toc-number">4.6.4.</span> <span class="toc-text">计算二叉树结点总数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">4.7.</span> <span class="toc-text">线索二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">4.8.</span> <span class="toc-text">树的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">4.8.1.</span> <span class="toc-text">双亲表示法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A9%E5%AD%90%E9%93%BE%E8%A1%A8"><span class="toc-number">4.8.2.</span> <span class="toc-text">孩子链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E6%B3%95"><span class="toc-number">4.8.3.</span> <span class="toc-text">孩子兄弟法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.9.</span> <span class="toc-text">树与二叉树的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">4.9.1.</span> <span class="toc-text">树转化为二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%A0%91"><span class="toc-number">4.9.2.</span> <span class="toc-text">二叉树转化为树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.10.</span> <span class="toc-text">森林与二叉树的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">4.10.1.</span> <span class="toc-text">森林转化为二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%A3%AE%E6%9E%97"><span class="toc-number">4.10.2.</span> <span class="toc-text">二叉树转换为森林</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">4.11.</span> <span class="toc-text">树和森林的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">4.11.1.</span> <span class="toc-text">树的遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">4.11.2.</span> <span class="toc-text">森林的遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">4.12.</span> <span class="toc-text">哈夫曼树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0%E7%AE%97%E6%B3%95"><span class="toc-number">4.12.1.</span> <span class="toc-text">哈夫曼树的构造算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">4.12.2.</span> <span class="toc-text">哈夫曼树的存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.12.3.</span> <span class="toc-text">构造哈夫曼树算法的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">4.13.</span> <span class="toc-text">哈夫曼编码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">4.13.1.</span> <span class="toc-text">哈夫曼编码的算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%9B%BE"><span class="toc-number">5.</span> <span class="toc-text">五、图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD"><span class="toc-number">5.1.</span> <span class="toc-text">图的基本概念和术语</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.</span> <span class="toc-text">图的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%EF%BC%88%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%EF%BC%89%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">5.2.1.</span> <span class="toc-text">数组（邻接矩阵）表示法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="toc-number">5.2.1.1.</span> <span class="toc-text">邻接矩阵的建立</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">5.2.1.2.</span> <span class="toc-text">邻接矩阵的优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">5.2.2.</span> <span class="toc-text">邻接表表示法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">邻接表的建立</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">5.2.2.2.</span> <span class="toc-text">邻接表的优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">5.2.3.</span> <span class="toc-text">邻接矩阵与邻接表的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8"><span class="toc-number">5.2.4.</span> <span class="toc-text">十字链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8"><span class="toc-number">5.2.5.</span> <span class="toc-text">邻接多重表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">5.3.</span> <span class="toc-text">图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88DFS%EF%BC%89"><span class="toc-number">5.3.1.</span> <span class="toc-text">深度优先搜索（DFS）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA%E7%9A%84%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86"><span class="toc-number">5.3.1.1.</span> <span class="toc-text">邻接矩阵表示的无向图的深度遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%E4%B8%8A%E7%9A%84%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86"><span class="toc-number">5.3.1.2.</span> <span class="toc-text">邻接表上的深度遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88BFS%EF%BC%89"><span class="toc-number">5.3.2.</span> <span class="toc-text">广度优先搜索（BFS）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">5.4.</span> <span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MST%E6%80%A7%E8%B4%A8"><span class="toc-number">5.4.1.</span> <span class="toc-text">MST性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%87%8C%E5%A7%86-Prim-%E7%AE%97%E6%B3%95"><span class="toc-number">5.4.2.</span> <span class="toc-text">普里姆 (Prim) 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94-Kruskal-%E7%AE%97%E6%B3%95"><span class="toc-number">5.4.3.</span> <span class="toc-text">克鲁斯卡尔 (Kruskal) 算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">5.5.</span> <span class="toc-text">最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%90%E6%BA%90%E7%82%B9%E5%88%B0%E5%85%B6%E4%BB%96%E5%90%84%E7%82%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">5.5.1.</span> <span class="toc-text">某源点到其他各点的最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Dijkstra%EF%BC%88%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%EF%BC%89%E7%AE%97%E6%B3%95"><span class="toc-number">5.5.1.1.</span> <span class="toc-text">Dijkstra（迪杰斯特拉）算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E4%B8%80%E5%AF%B9%E4%B8%A4%E7%82%B9%E4%B9%8B%E9%97%B4%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">5.5.2.</span> <span class="toc-text">任意一对两点之间最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Floyd%EF%BC%88%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%EF%BC%89%E7%AE%97%E6%B3%95"><span class="toc-number">5.5.2.1.</span> <span class="toc-text">Floyd（弗洛伊德）算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">5.6.</span> <span class="toc-text">拓扑排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="toc-number">5.7.</span> <span class="toc-text">关键路径</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%9F%A5%E6%89%BE"><span class="toc-number">6.</span> <span class="toc-text">六、查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">6.1.</span> <span class="toc-text">线性表的查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E6%B3%95"><span class="toc-number">6.1.1.</span> <span class="toc-text">顺序查找法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%E6%B3%95"><span class="toc-number">6.1.2.</span> <span class="toc-text">折半查找法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE%E6%B3%95"><span class="toc-number">6.1.3.</span> <span class="toc-text">分块查找法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">6.1.4.</span> <span class="toc-text">三种顺序查找的比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">6.2.</span> <span class="toc-text">树表的查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91"><span class="toc-number">6.2.1.</span> <span class="toc-text">二叉排序树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">6.2.1.1.</span> <span class="toc-text">二叉排序树的查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E7%94%9F%E6%88%90"><span class="toc-number">6.2.1.2.</span> <span class="toc-text">二叉排序树的插入和生成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">6.2.1.3.</span> <span class="toc-text">二叉排序树的删除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.2.2.</span> <span class="toc-text">平衡二叉树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">6.3.</span> <span class="toc-text">散列表的查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0"><span class="toc-number">6.3.1.</span> <span class="toc-text">散列函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%9D%80%E6%B3%95"><span class="toc-number">6.3.1.1.</span> <span class="toc-text">直接定址法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%A4%E7%95%99%E4%BD%99%E6%95%B0%E6%B3%95"><span class="toc-number">6.3.1.2.</span> <span class="toc-text">除留余数法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%B2%E7%AA%81"><span class="toc-number">6.3.2.</span> <span class="toc-text">冲突</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E6%94%BE%E5%AE%9A%E5%9D%80%E6%B3%95"><span class="toc-number">6.3.2.1.</span> <span class="toc-text">开放定址法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95"><span class="toc-number">6.3.2.1.1.</span> <span class="toc-text">线性探测法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E6%AC%A1%E6%8E%A2%E6%B5%8B%E6%B3%95"><span class="toc-number">6.3.2.1.2.</span> <span class="toc-text">二次探测法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%8E%A2%E6%B5%8B%E6%B3%95"><span class="toc-number">6.3.2.1.3.</span> <span class="toc-text">伪随机探测法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95"><span class="toc-number">6.3.2.2.</span> <span class="toc-text">链地址法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%8E%92%E5%BA%8F"><span class="toc-number">7.</span> <span class="toc-text">七、排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">7.1.</span> <span class="toc-text">插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">7.1.1.</span> <span class="toc-text">直接插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">7.1.2.</span> <span class="toc-text">折半插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">7.1.3.</span> <span class="toc-text">希尔排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="toc-number">7.2.</span> <span class="toc-text">交换排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">7.2.1.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">7.2.2.</span> <span class="toc-text">快速排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">7.3.</span> <span class="toc-text">选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">7.3.1.</span> <span class="toc-text">简单选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">7.3.2.</span> <span class="toc-text">堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E8%B0%83%E6%95%B4"><span class="toc-number">7.3.2.1.</span> <span class="toc-text">堆调整</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="toc-number">7.3.2.2.</span> <span class="toc-text">堆的建立</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">7.3.2.3.</span> <span class="toc-text">堆排序算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">7.4.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">7.5.</span> <span class="toc-text">基数排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">7.6.</span> <span class="toc-text">排序的对比</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/201b3bcb.html" title="maven工程"><img src="https://hakaimg.com/i/2022/10/05/nwneti.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="maven工程"/></a><div class="content"><a class="title" href="/post/201b3bcb.html" title="maven工程">maven工程</a><time datetime="2022-10-22T12:22:36.000Z" title="发表于 2022-10-22 20:22:36">2022-10-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/79666db.html" title="数据结构"><img src="https://hakaimg.com/i/2022/10/05/nwneti.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构"/></a><div class="content"><a class="title" href="/post/79666db.html" title="数据结构">数据结构</a><time datetime="2022-10-22T10:58:43.000Z" title="发表于 2022-10-22 18:58:43">2022-10-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/e5918a.html" title="SpringMvc"><img src="https://hakaimg.com/i/2022/10/05/nwneti.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringMvc"/></a><div class="content"><a class="title" href="/post/e5918a.html" title="SpringMvc">SpringMvc</a><time datetime="2022-10-22T09:11:18.000Z" title="发表于 2022-10-22 17:11:18">2022-10-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/6c92115f.html" title="Spring"><img src="https://hakaimg.com/i/2022/10/05/nwneti.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring"/></a><div class="content"><a class="title" href="/post/6c92115f.html" title="Spring">Spring</a><time datetime="2022-10-06T02:10:16.000Z" title="发表于 2022-10-06 10:10:16">2022-10-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/364418b3.html" title="hexo资源"><img src="https://hakaimg.com/i/2022/10/05/nwneti.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="hexo资源"/></a><div class="content"><a class="title" href="/post/364418b3.html" title="hexo资源">hexo资源</a><time datetime="2022-10-06T01:56:16.000Z" title="发表于 2022-10-06 09:56:16">2022-10-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 衿</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">11111</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'ki5BZQhHK9yTNTTH4H8vtwjz-gzGzoHsz',
      appKey: '6sX8zyNjuMtv2ZZdFU6HSvZ9',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://npm.elemecdn.com/hexo-butterfly-clock/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_injector_config();
  }
  </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax src="https://npm.elemecdn.com/hexo-butterfly-clock/lib/clock.min.js"></script><!-- hexo injector body_end end --></body></html>